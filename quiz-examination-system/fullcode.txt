AdminDashboardPage.xaml.cpp:
<code>
#include "pch.h"
#include "AdminDashboardPage.xaml.h"
#if __has_include("AdminDashboardPage.g.cpp")
#include "AdminDashboardPage.g.cpp"
#endif

using namespace winrt;
using namespace Microsoft::UI::Xaml;

namespace winrt::quiz_examination_system::implementation
{
    AdminDashboardPage::AdminDashboardPage()
    {
        InitializeComponent();
    }

    void AdminDashboardPage::ManageUsers_Click(winrt::Windows::Foundation::IInspectable const &, RoutedEventArgs const &)
    {
        ActionMessage().IsOpen(false);
        ActionMessage().Message(L"Open user management window");
        ActionMessage().Severity(Microsoft::UI::Xaml::Controls::InfoBarSeverity::Informational);
        ActionMessage().IsOpen(true);
    }

    void AdminDashboardPage::ShowMessage(hstring const &title, hstring const &message, Microsoft::UI::Xaml::Controls::InfoBarSeverity severity)
    {
        ActionMessage().Title(title);
        ActionMessage().Message(message);
        ActionMessage().Severity(severity);
        ActionMessage().IsOpen(true);
    }

}

</code>

AdminDashboardPage.xaml.h:
<code>
#pragma once

#include "AdminDashboardPage.g.h"
#include "SupabaseClient.h"
#include <winrt/Windows.Foundation.h>
#include <winrt/Microsoft.UI.Xaml.h>

namespace winrt::quiz_examination_system::implementation
{
    struct AdminDashboardPage : AdminDashboardPageT<AdminDashboardPage>
    {
        AdminDashboardPage();

        void ManageUsers_Click(winrt::Windows::Foundation::IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &);

    private:
        std::unique_ptr<::quiz_examination_system::SupabaseClient> m_supabaseClient;
        hstring m_currentUserId;
        void ShowMessage(hstring const &title, hstring const &message, Microsoft::UI::Xaml::Controls::InfoBarSeverity severity);
    };
}

namespace winrt::quiz_examination_system::factory_implementation
{
    struct AdminDashboardPage : AdminDashboardPageT<AdminDashboardPage, implementation::AdminDashboardPage>
    {
    };
}

</code>

App.xaml.cpp:
<code>
#include "pch.h"
#include "App.xaml.h"
#include "MainWindow.xaml.h"

using namespace winrt;
using namespace Microsoft::UI::Xaml;

namespace winrt::quiz_examination_system::implementation
{
    App::App()
    {
#if defined _DEBUG && !defined DISABLE_XAML_GENERATED_BREAK_ON_UNHANDLED_EXCEPTION
        UnhandledException([](IInspectable const &, UnhandledExceptionEventArgs const &e)
                           {
            if (IsDebuggerPresent())
            {
                auto errorMessage = e.Message();
                __debugbreak();
            } });
#endif
    }

    void App::OnLaunched([[maybe_unused]] LaunchActivatedEventArgs const &e)
    {
        window = make<MainWindow>();
        window.Activate();
    }
}

</code>

App.xaml.h:
<code>
#pragma once

#include "App.xaml.g.h"

namespace winrt::quiz_examination_system::implementation
{
    struct App : AppT<App>
    {
        App();

        void OnLaunched(Microsoft::UI::Xaml::LaunchActivatedEventArgs const&);

    private:
        winrt::Microsoft::UI::Xaml::Window window{ nullptr };
    };
}

</code>

BCryptPasswordHasher.h:
<code>
#pragma once

#include <string>
#include <winrt/Windows.Security.Cryptography.h>
#include <winrt/Windows.Security.Cryptography.Core.h>
#include <winrt/Windows.Storage.Streams.h>

namespace quiz_examination_system
{
    class BCryptPasswordHasher
    {
    private:
        static constexpr int WORK_FACTOR = 12;
        static constexpr int SALT_LENGTH = 16;

        static std::string GenerateSalt()
        {
            auto buffer = winrt::Windows::Security::Cryptography::CryptographicBuffer::GenerateRandom(SALT_LENGTH);
            auto saltHex = winrt::Windows::Security::Cryptography::CryptographicBuffer::EncodeToHexString(buffer);
            return winrt::to_string(saltHex);
        }

        static std::string PBKDF2Hash(const std::string &password, const std::string &salt, int iterations)
        {
            try
            {
                auto provider = winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider::OpenAlgorithm(
                    winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha256());

                auto passwordBuffer = winrt::Windows::Security::Cryptography::CryptographicBuffer::ConvertStringToBinary(
                    winrt::to_hstring(password),
                    winrt::Windows::Security::Cryptography::BinaryStringEncoding::Utf8);

                auto saltBuffer = winrt::Windows::Security::Cryptography::CryptographicBuffer::ConvertStringToBinary(
                    winrt::to_hstring(salt),
                    winrt::Windows::Security::Cryptography::BinaryStringEncoding::Utf8);

                auto key = provider.CreateKey(passwordBuffer);

                winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters params =
                    winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForPbkdf2(saltBuffer, iterations);

                auto derivedKey = winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DeriveKeyMaterial(
                    key,
                    params,
                    32);

                auto hashString = winrt::Windows::Security::Cryptography::CryptographicBuffer::EncodeToHexString(derivedKey);
                return winrt::to_string(hashString);
            }
            catch (...)
            {
                return "";
            }
        }

    public:
        static hstring HashPassword(hstring const &password)
        {
            try
            {
                std::string pwd = winrt::to_string(password);
                std::string salt = GenerateSalt();

                int iterations = 1 << WORK_FACTOR;
                std::string hash = PBKDF2Hash(pwd, salt, iterations);

                if (hash.empty())
                {
                    return L"";
                }

                std::string result = "$pbkdf2-sha256$i=" + std::to_string(iterations) + "$" + salt + "$" + hash;
                return winrt::to_hstring(result);
            }
            catch (...)
            {
                return hstring(L"");
            }
        }

        static bool VerifyPassword(hstring const &password, hstring const &storedHash)
        {
            try
            {
                std::string pwd = winrt::to_string(password);
                std::string stored = winrt::to_string(storedHash);

                if (stored.find("$pbkdf2-sha256$i=") != 0)
                {
                    return false;
                }

                size_t iterPos = stored.find("$i=") + 3;
                size_t saltPos = stored.find("$", iterPos);
                size_t hashPos = stored.find("$", saltPos + 1);

                if (saltPos == std::string::npos || hashPos == std::string::npos)
                {
                    return false;
                }

                int iterations = std::stoi(stored.substr(iterPos, saltPos - iterPos));
                std::string salt = stored.substr(saltPos + 1, hashPos - saltPos - 1);
                std::string storedHashPart = stored.substr(hashPos + 1);

                std::string computedHash = PBKDF2Hash(pwd, salt, iterations);

                return computedHash == storedHashPart;
            }
            catch (...)
            {
                return false;
            }
        }
    };
}

</code>

checklist.md:
<code>
Dựa trên tài liệu **SRS v1.5** (Project: Quiz Examination System, Group 05) và yêu cầu nộp bài của môn học Công nghệ phần mềm, dưới đây là **Checklist kiểm tra chi tiết** để bạn rà soát toàn bộ dự án trước khi nộp.

Checklist này được chia theo các hạng mục đánh giá của môn học: **Program (5đ)**, **Tools (2đ)**, **Test cases (2đ)** và **Quy cách nộp bài**.

---

### PHẦN 1: KIỂM TRA CHỨC NĂNG (FUNCTIONAL REQUIREMENTS)
*Mục tiêu: Đảm bảo code chạy đúng logic đã viết trong SRS v1.5.*

#### 1. Quản lý xác thực (Authentication - UC01, UC10, UC11, UC12)
- [ ] **Đăng nhập:** Hệ thống có chặn đăng nhập nếu sai mật khẩu quá 5 lần không? (Yêu cầu khóa 30 phút).
- [ ] **Phân quyền:**
    - [ ] Student đăng nhập có bị chặn truy cập màn hình Teacher/Admin không?.
    - [ ] Admin có quyền reset mật khẩu cho user khác không?.
- [ ] **Đổi mật khẩu:** Mật khẩu mới có bị từ chối nếu dài quá 72 bytes không?.
- [ ] **Quên mật khẩu:** Màn hình Login **KHÔNG** được có nút "Forgot Password" (chức năng này chỉ dành cho Admin thực hiện thủ công).

#### 2. Ngân hàng câu hỏi (Question Bank - UC02)
- [ ] **Validation:** Khi tạo câu hỏi, hệ thống có bắt buộc phải chọn **chính xác 1 đáp án đúng** không?.
- [ ] **Ràng buộc xóa:** Khi Teacher xóa câu hỏi đang nằm trong một Quiz đang hoạt động (Active), hệ thống có hiện cảnh báo và chặn xóa không?.

#### 3. Quản lý bài thi (Quiz Management - UC03, UC06, UC08)
- [ ] **Cấu hình Quiz:**
    - [ ] Có cho phép set `Max Attempts` (số lần làm bài tối đa) là số cụ thể hoặc "Unlimited" không?.
    - [ ] Có chặn nếu `Time Limit` hoặc `Total Points` là số âm không?.
- [ ] **Shuffle (Trộn):** Tính năng trộn câu hỏi và trộn đáp án có hoạt động thực tế khi Student làm bài không?.
- [ ] **Phân quyền xóa:**
    - [ ] Teacher: Xóa Quiz có bài làm của HS $\rightarrow$ **Hệ thống phải CHẶN**.
    - [ ] Admin: Chọn "Purge Permanently" $\rightarrow$ **Hệ thống phải XÓA** cả Quiz và toàn bộ kết quả liên quan.

#### 4. Làm bài thi (Take Quiz - UC04)
- [ ] **Quy trình 3 bước:** Từ lúc đăng nhập đến lúc bắt đầu làm bài có $\le$ 3 bước không? (Login $\rightarrow$ Dashboard $\rightarrow$ Take Quiz).
- [ ] **Auto-save:** Khi chuyển câu hỏi (Next/Prev), đáp án cũ có được lưu lại không?.
- [ ] **Timer:** Khi hết giờ, hệ thống có tự động nộp bài (Auto-submit) không?.
- [ ] **Chặn làm lại:** Nếu sinh viên đã hết lượt làm bài (Max attempts reached), nút "Take Quiz" có bị mờ hoặc chặn không?.

#### 5. Chấm điểm & Báo cáo (Grading & Reporting - UC05)
- [ ] **Tính điểm:** Logic tính điểm có chính xác là: `Tổng điểm = Tổng (Điểm câu đúng)`, câu sai/bỏ trống = 0 điểm không?.
- [ ] **Hiển thị kết quả:** Nếu Quiz cài đặt `Result Visibility` là "After Quiz End", sinh viên nộp bài xong có bị ẩn điểm số cho đến khi hết hạn bài thi không?.
- [ ] **Export CSV:** File CSV xuất ra có đủ các cột: Username, Attempt Number, Score, Time Spent không?.

---

### PHẦN 2: KIỂM TRA YÊU CẦU PHI CHỨC NĂNG (NFR)
*Mục tiêu: Đạt điểm tối đa phần kỹ thuật và triển khai.*

- [ ] **NFR-02 (Bảo mật):**
    - [ ] Kiểm tra Database (Supabase): Cột `password_hash` trong bảng `users` có phải là chuỗi mã hóa (hash) không? Tuyệt đối **KHÔNG** lưu plain text.
    - [ ] Thuật toán mã hóa sử dụng hàm hash để bảo vệ mật khẩu (kiểm tra trong file `PasswordHasher.h` - hash với prefix `$2a$10$` để mô phỏng định dạng bcrypt-like).
- [ ] **NFR-06 (Docker):**
    - [ ] Trong thư mục nộp bài có file `Dockerfile` không?.
    - [ ] Dockerfile có build được ứng dụng hoặc backend service không?.
- [ ] **Cơ sở dữ liệu:** Code C++ có đang kết nối thực sự tới **Supabase (PostgreSQL)** không? (Lưu ý: Đoạn code mẫu `main.cpp` dòng đang dùng `vector` giả lập trên RAM $\rightarrow$ Cần thay thế bằng gọi API/Database thật để đúng yêu cầu SRS).

---

### PHẦN 3: KIỂM TRA TÀI LIỆU & CÔNG CỤ (DOCS & TOOLS)
*Mục tiêu: Đạt 2 điểm Tools + 2 điểm Test cases.*

#### 1. Cấu trúc thư mục nộp bài
Tên thư mục: `ProgAndTest_Group05` (hoặc GroupXY), bên trong gồm:
- [ ] **Source code:** `.cpp`, `.h`, `.xaml`...
- [ ] **Testing document:** File Excel/Word chứa Test Cases.
- [ ] **Docker file:** File cấu hình Docker.
- [ ] **Evidence of tools:** File (Word/PDF) chứa ảnh chụp màn hình minh chứng việc nhóm đã sử dụng các công cụ:
    - [ ] Quản lý source: Ảnh chụp **GitHub/GitLab** (commit history).
    - [ ] Vẽ biểu đồ: Ảnh chụp **Diagrams.net** (hoặc công cụ tương đương).
    - [ ] Quản lý lỗi (Bug tracking): Ảnh chụp **Jira / Excel / Trello** theo dõi bug.
    - [ ] IDE: Ảnh chụp Visual Studio/VS Code.

#### 2. Tài liệu kiểm thử (Testing Document)
Phải có các Test Case khớp với Use Case trong SRS. Ví dụ mẫu:
- [ ] **TC_Auth_01 (Login Success):** Input đúng $\rightarrow$ Vào Dashboard.
- [ ] **TC_Auth_02 (Login Fail):** Input sai pass $\rightarrow$ Báo lỗi.
- [ ] **TC_Quiz_01 (Max Attempts):** Cố làm bài lần 2 khi max=1 $\rightarrow$ Hệ thống chặn.
- [ ] **TC_Admin_01 (Purge):** Admin xóa Quiz có attempt $\rightarrow$ Xóa thành công & Log ghi nhận.

---

### PHẦN 4: CHUẨN BỊ BÁO CÁO (DEMO)
*Mục tiêu: Đạt 1 điểm thuyết trình.*

- [ ] **Kịch bản Demo:** Chuẩn bị sẵn 1 kịch bản chạy mượt mà:
    1.  Đăng nhập Admin $\rightarrow$ Tạo User Teacher & Student.
    2.  Đăng nhập Teacher $\rightarrow$ Tạo Câu hỏi $\rightarrow$ Tạo Quiz (set time ngắn để test).
    3.  Đăng nhập Student $\rightarrow$ Làm bài $\rightarrow$ Kiểm tra Auto-submit khi hết giờ.
    4.  Quay lại Teacher $\rightarrow$ Xem Report $\rightarrow$ Xuất CSV.
    5.  Admin xóa Quiz để chứng minh chức năng Purge.
- [ ] **Mở sẵn công cụ:** Trước khi lên bảng, mở sẵn Git, Supabase Dashboard, và file Excel Test Case để show cho giáo viên xem khi được hỏi.

**Lưu ý quan trọng nhất:** Hãy sửa lại code phần kết nối Database nếu bạn vẫn đang dùng dữ liệu giả (`vector users` trong `main.cpp`). SRS yêu cầu rõ ràng database phải host trên Supabase Cloud.















Dựa trên tài liệu SRS, nguyên lý thiết kế giao diện (UI Design Principles) từ nguồn, và trạng thái hiện tại của dự án (Backend đã xong, UI chưa tương tác), đây là **Checklist hướng dẫn triển khai UI (No-code)** để biến giao diện tĩnh thành một ứng dụng tương tác hoàn chỉnh.

Mục tiêu là kết nối các RPC bạn vừa viết với các sự kiện (Events) trên màn hình XAML.

---

### PHẦN 1: TEACHER DASHBOARD (Ưu tiên cao nhất - Vì cần dữ liệu để Student test)

Màn hình này thực hiện **UC-02 (Question Bank)** và **UC-03 (Create Quiz)**.

#### 1. Tab "Question Bank" (Ngân hàng câu hỏi)
- [ ] **Hiển thị danh sách (Data Binding):**
    - Tạo một `ListView` hoặc `DataGrid` trong XAML.
    - **Sự kiện `Page_Loaded`:** Gọi hàm `SupabaseClient::GetQuestions()`.
    - **UI Update:** Khi dữ liệu về (callback), gán vào `ItemsSource` của ListView.
- [ ] **Chức năng Thêm mới (Add Question):**
    - Tạo nút "Add Question".
    - **Sự kiện `Click`:** Mở một `ContentDialog` chứa các TextBox (Câu hỏi, 4 đáp án) và ComboBox (Đáp án đúng, Độ khó).
    - **Nút "Save" trong Dialog:** Gọi `SupabaseClient::CreateQuestionValidated()`.
    - **Phản hồi:** Nếu thành công $\rightarrow$ Đóng Dialog, hiện thông báo xanh (TeachingTip), reload lại danh sách.
- [ ] **Chức năng Xóa (Delete Question):**
    - Thêm nút "Delete" vào mỗi dòng (hoặc nút trên Toolbar xử lý dòng đang chọn).
    - **Sự kiện `Click`:** Gọi `SupabaseClient::DeleteQuestionSafe()`.
    - **Xử lý lỗi (Quan trọng):** Nếu server trả về `blocked` (do câu hỏi đang nằm trong Quiz active) $\rightarrow$ Hiện thông báo lỗi đỏ: "Không thể xóa câu hỏi đang được sử dụng".

#### 2. Tab "Manage Quizzes" (Quản lý đề thi)
- [ ] **Hiển thị danh sách Quiz:**
    - Tương tự Question Bank, load danh sách Quiz do giáo viên tạo.
- [ ] **Tạo đề thi (Create Quiz Flow):**
    - **Bước 1 (Info):** Nhập Tên đề, Thời gian, Số lần làm bài (Max Attempts).
    - **Bước 2 (Select Questions):** Hiện danh sách câu hỏi với `CheckBox` để giáo viên tích chọn.
    - **Bước 3 (Submit):** Gọi hàm tạo Quiz, gửi kèm danh sách ID các câu hỏi đã chọn.
- [ ] **Xem Báo cáo (View Report - UC-05):**
    - Chọn một Quiz từ danh sách $\rightarrow$ Hiện nút "View Report".
    - **Sự kiện:** Gọi `GetQuizAttemptsReport`.
    - **UI:** Đổ dữ liệu vào bảng thống kê (Tên HS, Điểm, Thời gian nộp).
    - **Nút "Export CSV":** Gọi hàm download CSV bạn đã cấu hình header `Accept: text/csv`.

---

### PHẦN 2: STUDENT DASHBOARD (Luồng cốt lõi UC-04)

Đây là phần quan trọng nhất để Demo. Theo **NFR-04**, sinh viên phải vào thi được trong vòng 3 bước.

#### 1. Màn hình chính (Dashboard)
- [ ] **Danh sách đề thi (Available Quizzes):**
    - **Sự kiện `Page_Loaded`:** Gọi `GetStudentQuizzes()`.
    - **UI:** Sử dụng `GridView` (dạng thẻ bài) hiện Tên đề, Thời gian, Trạng thái (Chưa làm/Đã làm).
    - **Tương tác:** Click vào thẻ $\rightarrow$ Điều hướng sang trang `ExamPage`.

#### 2. Màn hình làm bài (Exam Page) - Quan trọng
*Lưu ý: Màn hình này cần thiết kế cẩn thận để tránh gian lận.*

- [ ] **Load đề thi:**
    - Gọi `GetQuizQuestions()`.
    - **Lưu ý:** Dữ liệu trả về **KHÔNG** được chứa trường `is_correct` (đáp án đúng) để đảm bảo bảo mật NFR-02.
- [ ] **Giao diện thi:**
    - Chia màn hình: Bên trái là danh sách số câu (Navigation), Bên phải là Nội dung câu hỏi hiện tại.
    - Dùng `RadioButton` cho 4 đáp án.
- [ ] **Điều hướng & Auto-save:**
    - Khi bấm nút "Next" hoặc "Previous" $\rightarrow$ Lưu tạm đáp án vào biến cục bộ (hoặc gọi API save nháp nếu muốn xịn).
- [ ] **Đồng hồ đếm ngược (Timer):**
    - Sử dụng `DispatcherTimer` của WinUI.
    - **Logic:** Khi timer = 0 $\rightarrow$ Tự động gọi hàm `SubmitAttempt`.
- [ ] **Nộp bài (Submit):**
    - Nút "Submit" cần hiện `ContentDialog` xác nhận: "Bạn có chắc muốn nộp bài?".
    - **Hành động:** Gọi RPC `submit_quiz_attempt` gửi kèm danh sách câu trả lời.
    - **Kết quả:** Server trả về điểm số ngay lập tức $\rightarrow$ Hiện Dialog thông báo điểm số.

---

### PHẦN 3: ADMIN DASHBOARD (Quản trị hệ thống)

#### 1. Tab "User Management"
- [ ] **Quản lý trạng thái:**
    - Danh sách User có `ToggleSwitch` cho cột "Active/Disabled".
    - **Sự kiện `Toggled`:** Gọi RPC update status.
- [ ] **Reset Mật khẩu:**
    - Nút "Reset Password" (UC-12).
    - **Logic:** Gọi API reset về mật khẩu mặc định (ví dụ: "123456") và hiện thông báo copy cho Admin.

#### 2. Tab "System Audit"
- [ ] **Xem Log:**
    - Chỉ cần `DataGrid` read-only hiển thị bảng `audit_logs` từ Supabase.
    - Giúp Admin theo dõi ai vừa login sai 5 lần (tính năng bảo mật bạn vừa làm).

---

### PHẦN 4: UI FEEDBACK & UX (Trải nghiệm người dùng)

Theo nguồn về thiết kế UI, bạn cần đảm bảo:

- [ ] **Feedback:** Mọi hành động gọi xuống Supabase (Async) đều phải hiện `ProgressRing` (vòng xoay loading) và làm mờ màn hình để người dùng biết hệ thống đang xử lý.
- [ ] **Consistency:** Các nút "Xóa" nên luôn có màu đỏ, nút "Lưu/Thêm" màu xanh (Accent Color).
- [ ] **Error Handling:** Khi RPC trả về lỗi (mất mạng, lỗi logic), phải hiện `TeachingTip` hoặc `ContentDialog` báo lỗi rõ ràng, không để app bị crash.

### Bước tiếp theo bạn cần làm:
Hãy mở file **`StudentDashboardPage.xaml`** trước.
1.  Vẽ một `GridView` có tên là `QuizListGrid`.
2.  Trong file `.cpp`, viết hàm `LoadQuizzes` gọi RPC `get_student_quizzes`.
3.  Khi có data, loop qua và thêm item vào `QuizListGrid`.

Bạn có muốn tôi viết mẫu đoạn XAML cho cái `GridView` hiển thị bài thi đẹp mắt không?
</code>

DATABASE_SCHEMA.md:
<code>
# Quiz Examination System - Database Schema Documentation

**Generated**: January 27, 2026  
**Project URL**: https://tuciofxdzzrzwzqsltps.supabase.co  
**Total Tables**: 8  
**Total Migrations**: 64

## Database Overview

Database hỗ trợ hệ thống thi trắc nghiệm với RBAC, audit logging, và quản lý quiz.

### Key Features
- Role-based access (Admin, Teacher, Student)
- Row-Level Security (RLS) với 12 policies cho users
- Account lockout sau failed login attempts
- Audit logging cho security events
- PBKDF2-SHA256 password hashing
- Quiz creation, assignment, và grading
- Automated scoring và reporting

## Database Tables

### 1. users (12 rows)
Store user accounts với authentication và authorization data

| Column | Type | Constraints | Default |
|--------|------|-------------|---------|
| `id` | char(6) | PRIMARY KEY | - |
| `username` | text | UNIQUE, NOT NULL | - |
| `password_hash` | text | NOT NULL | - |
| `role` | text | CHECK: Student/Teacher/Admin | - |
| `failed_login_count` | integer | - | 0 |
| `status` | text | - | 'ACTIVE' |
| `locked_until` | timestamp | NULLABLE | - |
| `created_at` | timestamp | - | CURRENT_TIMESTAMP |
| `updated_at` | timestamp | - | CURRENT_TIMESTAMP |
| `created_by` | char(6) | FK → users.id | - |

**CHECK Constraints**:
- `role IN ('Admin', 'Teacher', 'Student')`
- `password_hash`: PBKDF2 hoặc legacy SHA256 format

**Foreign Keys**:
- `created_by` → `users.id`

**RLS**: Enabled với 12 policies

### 2. questions (3 rows)
Store question bank với multiple-choice options

| Column | Type | Constraints | Default |
|--------|------|-------------|---------|
| `id` | char(6) | PRIMARY KEY | - |
| `created_by` | char(6) | FK → users.id | - |
| `question_text` | text | NOT NULL | - |
| `option_a` | text | NOT NULL | - |
| `option_b` | text | NOT NULL | - |
| `option_c` | text | NOT NULL | - |
| `option_d` | text | NOT NULL | - |
| `correct_option` | varchar | CHECK: A/B/C/D | - |
| `difficulty_level` | varchar | CHECK: easy/medium/hard | - |
| `topic` | text | NULLABLE | - |
| `created_at` | timestamp | - | CURRENT_TIMESTAMP |
| `updated_at` | timestamp | - | CURRENT_TIMESTAMP |

**CHECK Constraints**:
- `correct_option IN ('A', 'B', 'C', 'D')`
- `difficulty_level IN ('easy', 'medium', 'hard')`

**Foreign Keys**:
- `created_by` → `users.id`

**RLS**: Enabled với 3 policies

### 3. quizzes (0 rows)
Store quiz metadata và settings

| Column | Type | Constraints | Default |
|--------|------|-------------|---------|
| `id` | char(6) | PRIMARY KEY | - |
| `created_by` | char(6) | FK → users.id | - |
| `title` | varchar | NOT NULL | - |
| `time_limit_minutes` | integer | CHECK > 0 | - |
| `total_points` | integer | CHECK > 0 | - |
| `shuffle_questions` | boolean | - | false |
| `shuffle_answers` | boolean | - | false |
| `result_visibility` | varchar | CHECK | 'immediate' |
| `max_attempts` | varchar | CHECK regex | 'unlimited' |
| `created_at` | timestamp | - | CURRENT_TIMESTAMP |
| `updated_at` | timestamp | - | CURRENT_TIMESTAMP |

**CHECK Constraints**:
- `time_limit_minutes > 0`
- `total_points > 0`
- `result_visibility IN ('immediate', 'after_quiz_end', 'manual_release')`
- `max_attempts ~ '^
- `result_visibility IN ('immediate', 'after_quiz_end', 'manual_release')`
- `max_attempts ~ '^([0-9]+|unlimited)$'`

**Foreign Keys**:
- `created_by` → `users.id`

**RLS**: Enabled với 2 policies

### 4. quiz_questions (0 rows)
Link questions to quizzes (junction table)

| Column | Type | Constraints | Default |
|--------|------|-------------|---------|
| `id` | char(6) | PRIMARY KEY | - |
| `quiz_id` | char(6) | FK → quizzes.id | - |
| `question_id` | char(6) | FK → questions.id | - |
| `points` | integer | CHECK > 0 | - |
| `order_num` | integer | - | - |
| `created_at` | timestamp | - | CURRENT_TIMESTAMP |

**CHECK Constraints**:
- `points > 0`

**Foreign Keys**:
- `quiz_id` → `quizzes.id`
- `question_id` → `questions.id`

**RLS**: Enabled với 1 policy

### 5. quiz_assignments (0 rows)
Assign quizzes to students với time windows

| Column | Type | Constraints | Default |
|--------|------|-------------|---------|
| `id` | char(6) | PRIMARY KEY | - |
| `quiz_id` | char(6) | FK → quizzes.id | - |
| `assigned_to` | char(6) | FK → users.id | - |
| `start_time` | timestamp | NOT NULL | - |
| `end_time` | timestamp | NOT NULL | - |
| `created_at` | timestamp | - | CURRENT_TIMESTAMP |

**Foreign Keys**:
- `quiz_id` → `quizzes.id`
- `assigned_to` → `users.id`

**RLS**: ✅ Enabled

---Enabled với 1 policy

### 6. quiz_attempts (0 rows)
Track student quiz attempts và
|--------|------|-------------|---------|
| `id` | char(6) | PRIMARY KEY | - |
| `quiz_id` | char(6) | FK → quizzes.id | - |
| `student_id` | char(6) | FK → users.id | - |
| `attempt_number` | integer | NOT NULL | - |
| `score` | integer | NULLABLE | - |
| `total_points` | integer | NULLABLE | - |
| `correct_count` | integer | - | 0 |
| `incorrect_count` | integer | - | 0 |
| `status` | varchar | CHECK | **'in_progress'** |
| `started_at` | timestamp | NOT NULL | - |
| `submitted_at` | timestamp | NULLABLE | - |
| `time_spent_seconds` | integer | NULLABLE | - |
| `created_at` | timestamp | - | CURRENT_TIMESTAMP |

**CHECK Constraints**:
- `status IN ('in_progress', 'submitted')`

**Important Note**: 
> ⚠️ Default status is `'in_progress'` (changed via migration `fix_quiz_attempts_default_status`)
Foreign Keys**:
- `quiz_id` → `quizzes.id`
- `student_id` → `users.id`

**RLS**: Enabled với 2 policies

### 7. quiz_answers (0 rows)
Store individual question answers cho mỗi
|--------|------|-------------|---------|
| `id` | char(6) | PRIMARY KEY | - |
| `attempt_id` | char(6) | FK → quiz_attempts.id | - |
| `question_id` | char(6) | FK → questions.id | - |
| `selected_option` | varchar | NULLABLE (A/B/C/D) | - |
| `is_correct` | boolean | NULLABLE | - |
| `created_at` | timestamp | - | CURRENT_TIMESTAMP |

**Foreign Keys**:
- `attempt_id` → `quiz_attempts.id`
- `question_id` → `questions.id`

**RLS**: ✅ Enabled

---

### 8. **audit_logs** (21 rows)
**PurposeEnabled với 1 policy

### 8. audit_logs (22 rows)
Security audit trail cho
| `actor_id` | char(6) | NOT NULL | - |
| `target_table` | varchar | NULLABLE | - |
| `target_id` | char(6) | NULLABLE | - |
| `details` | jsonb | NULLABLE | - |
| `created_at` | timestamp | - | CURRENT_TIMESTAMP |

**RLS**: ✅ Enabled

---Enabled (no policies - read-only via service role)

## Row-Level Security (RLS) Summary

| Table | RLS Enabled | Policy Count |
|-------|-------------|--------------|
| users | Yes | 12 |
| questions | Yes | 3 |
| quizzes | Yes | 2 |
| quiz_questions | Yes | 1 |
| quiz_assignments | Yes | 1 |
| quiz_attempts | Yes | 2 |
| quiz_answers | Yes | 1 |
| audit_logs | Yes | 0 |

## Stored Procedures (RPC)

### Authentication
- `handle_login_success` - Reset failed login count
- `handle_login_failure` - Increment failed count, lock sau 5 attempts
- `check_account_locked` - Verify lock status

### Quiz Operations
- `submit_quiz_attempt` - Submit answers và calculate score
- `get_quiz_questions_v2` - Retrieve quiz questions
- `get_student_quizzes_v2` - Get assigned quizzes
- `get_attempt_details_with_answers` - Detailed attempt results
- `get_quiz_attempts_report` - Generate quiz report

### Password Management
- `generate_pbkdf2_hash` - Generate PBKDF2-SHA256 hash
- `is_pbkdf2_hash` - Check hash format
- `is_legacy_hash` - Check legacy format

## Migration History

Total migrations: 64

Recent migrations:
- `prepare_for_pbkdf2_passwords` - PBKDF2 support
- `migrate_all_users_to_pbkdf2` - Convert passwords
- `enable_rls_for_users_table` - Fix security warning

## Security Features

### Password Hashing
- Format: `$pbkdf2-sha256$i=4096$[salt]$[hash]`
- Algorithm: PBKDF2-SHA256 với 4096 iterations
- Backward compatible với legacy SHA256

### Account Security
- Failed login tracking
- Auto-lockout sau 5 failed attempts
- Audit trail cho sensitive operations

### RLS Protection
- Teachers chỉ modify questions/quizzes của họ
- Students chỉ view assigned quizzes
- Admin có full access

## Data Statistics

- Users: 12 accounts
- Questions: 3 items
- Quizzes: 0 active
- Attempts: 0 completed
- Audit logs: 22 events

**Last Updated**: January 27, 2026  
**Schema Version**: v2.0 (64 migrations
</code>

docker-compose.yml:
<code>
version: '3.8'

services:
  quiz-app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: quiz-examination-system
    environment:
      - SUPABASE_URL=${SUPABASE_URL}
      - SUPABASE_ANON_KEY=${SUPABASE_ANON_KEY}
      - TZ=Asia/Ho_Chi_Minh
    volumes:
      - app-data:/app/data
    restart: unless-stopped
    networks:
      - quiz-network
    # Note: WinUI 3 apps require Windows containers
    # Ensure Docker Desktop is configured for Windows containers
    
  # Optional: Add a reverse proxy or monitoring service
  # nginx:
  #   image: nginx:latest
  #   ports:
  #     - "80:80"
  #   networks:
  #     - quiz-network

volumes:
  app-data:
    driver: local

networks:
  quiz-network:
    driver: bridge

# To run:
# 1. Create .env file with SUPABASE_URL and SUPABASE_ANON_KEY
# 2. Run: docker-compose up -d
# 3. To stop: docker-compose down
# 4. To view logs: docker-compose logs -f quiz-app

</code>

ExamPage.xaml.cpp:
<code>
#include "pch.h"
#include "ExamPage.xaml.h"
#if __has_include("ExamPage.g.cpp")
#include "ExamPage.g.cpp"
#endif

using namespace winrt;
using namespace Microsoft::UI::Xaml;
using namespace Microsoft::UI::Xaml::Controls;
using namespace Windows::Foundation;
using namespace Microsoft::UI::Dispatching;
using namespace Windows::UI::Xaml::Interop;

namespace winrt::quiz_examination_system::implementation
{
    ExamPage::ExamPage()
    {
        InitializeComponent();
        m_supabaseClient = std::make_unique<::quiz_examination_system::SupabaseClient>();
    }

    ExamPage::ExamPage(hstring const &quizId, hstring const &studentId) : ExamPage()
    {
        m_quizId = quizId;
        m_studentId = studentId;
    }

    void ExamPage::Page_Loaded(IInspectable const &, RoutedEventArgs const &)
    {
        if (m_quizId.empty() || m_studentId.empty())
        {
            ShowMessage(L"Missing quiz or student information", InfoBarSeverity::Error);
            return;
        }

        LoadQuizData();
        LoadQuestions();
    }

    void ExamPage::LoadQuizData()
    {
        QuizTitleText().Text(L"Loading quiz information...");
        QuizInfoText().Text(L"");
    }

    void ExamPage::LoadQuestions()
    {
        m_supabaseClient->OnQuizQuestionsLoaded = [this](bool success, std::vector<::quiz_examination_system::SupabaseClient::QuestionData> questions)
        {
            if (!success || questions.empty())
            {
                ShowMessage(L"Failed to load questions", InfoBarSeverity::Error);
                return;
            }

            m_questions = questions;

            std::sort(m_questions.begin(), m_questions.end(),
                      [](const auto &a, const auto &b)
                      { return a.order_num < b.order_num; });

            Windows::Foundation::Collections::IVector<IInspectable> items =
                winrt::single_threaded_observable_vector<IInspectable>();

            for (size_t i = 0; i < m_questions.size(); ++i)
            {
                hstring itemText = hstring(L"Q") + to_hstring(i + 1);
                items.Append(box_value(itemText));
            }
            QuestionListView().ItemsSource(items);

            if (!m_questions.empty())
            {
                int totalPoints = 0;
                for (const auto &q : m_questions)
                {
                    totalPoints += q.points;
                }

                QuizTitleText().Text(L"Quiz Examination");
                QuizInfoText().Text(hstring(L"Questions: ") + to_hstring(m_questions.size()) +
                                    L" | Total Points: " + to_hstring(totalPoints));

                m_timeLimitSeconds = 30 * 60;
                m_timeRemainingSeconds = m_timeLimitSeconds;

                DisplayQuestion(0);
                StartTimer();
            }
        };

        m_supabaseClient->GetQuizQuestions(m_quizId);
    }

    void ExamPage::DisplayQuestion(int index)
    {
        if (index < 0 || index >= static_cast<int>(m_questions.size()))
            return;

        SaveCurrentAnswer();

        m_currentQuestionIndex = index;
        auto &q = m_questions[index];

        QuestionNumberText().Text(hstring(L"Question ") + to_hstring(index + 1) + L" / " + to_hstring(m_questions.size()));
        QuestionText().Text(q.question_text);

        OptionA().Content(box_value(hstring(L"A. ") + q.option_a));
        OptionB().Content(box_value(hstring(L"B. ") + q.option_b));
        OptionC().Content(box_value(hstring(L"C. ") + q.option_c));
        OptionD().Content(box_value(hstring(L"D. ") + q.option_d));

        OptionA().IsChecked(false);
        OptionB().IsChecked(false);
        OptionC().IsChecked(false);
        OptionD().IsChecked(false);

        auto it = m_answers.find(q.question_id);
        if (it != m_answers.end())
        {
            if (it->second == L"A")
                OptionA().IsChecked(true);
            else if (it->second == L"B")
                OptionB().IsChecked(true);
            else if (it->second == L"C")
                OptionC().IsChecked(true);
            else if (it->second == L"D")
                OptionD().IsChecked(true);
        }

        PrevButton().IsEnabled(index > 0);
        NextButton().IsEnabled(index < static_cast<int>(m_questions.size()) - 1);

        QuestionListView().SelectedIndex(index);
    }

    void ExamPage::SaveCurrentAnswer()
    {
        if (m_currentQuestionIndex < 0 || m_currentQuestionIndex >= static_cast<int>(m_questions.size()))
            return;

        auto &q = m_questions[m_currentQuestionIndex];

        if (OptionA().IsChecked().GetBoolean())
            m_answers[q.question_id] = L"A";
        else if (OptionB().IsChecked().GetBoolean())
            m_answers[q.question_id] = L"B";
        else if (OptionC().IsChecked().GetBoolean())
            m_answers[q.question_id] = L"C";
        else if (OptionD().IsChecked().GetBoolean())
            m_answers[q.question_id] = L"D";
        else
            m_answers.erase(q.question_id);
    }

    void ExamPage::StartTimer()
    {
        auto queue = DispatcherQueue::GetForCurrentThread();
        m_timer = queue.CreateTimer();

        m_timer.Interval(std::chrono::seconds(1));
        m_timer.IsRepeating(true);

        m_timer.Tick([this](auto &&, auto &&)
                     {
            m_timeRemainingSeconds--;
            UpdateTimerDisplay();

            if (m_timeRemainingSeconds <= 0)
            {
                m_timer.Stop();
                ShowMessage(L"Time's up! Auto-submitting...", InfoBarSeverity::Warning);
                SubmitAttempt();
            } });

        m_timer.Start();
        UpdateTimerDisplay();
    }

    void ExamPage::UpdateTimerDisplay()
    {
        int minutes = m_timeRemainingSeconds / 60;
        int seconds = m_timeRemainingSeconds % 60;

        wchar_t buffer[10];
        swprintf_s(buffer, L"%02d:%02d", minutes, seconds);
        TimerText().Text(buffer);

        if (m_timeRemainingSeconds <= 60)
        {
            TimerText().Foreground(Microsoft::UI::Xaml::Media::SolidColorBrush(
                Microsoft::UI::Colors::Red()));
        }
    }

    void ExamPage::QuestionListView_SelectionChanged(IInspectable const &, SelectionChangedEventArgs const &)
    {
        int index = QuestionListView().SelectedIndex();
        if (index >= 0 && index < static_cast<int>(m_questions.size()))
        {
            DisplayQuestion(index);
        }
    }

    void ExamPage::PrevButton_Click(IInspectable const &, RoutedEventArgs const &)
    {
        if (m_currentQuestionIndex > 0)
        {
            DisplayQuestion(m_currentQuestionIndex - 1);
        }
    }

    void ExamPage::NextButton_Click(IInspectable const &, RoutedEventArgs const &)
    {
        if (m_currentQuestionIndex < static_cast<int>(m_questions.size()) - 1)
        {
            DisplayQuestion(m_currentQuestionIndex + 1);
        }
    }

    fire_and_forget ExamPage::SubmitButton_Click(IInspectable const &, RoutedEventArgs const &)
    {
        auto lifetime = get_strong();

        ContentDialog confirmDialog;
        confirmDialog.XamlRoot(this->XamlRoot());
        confirmDialog.Title(box_value(L"Confirm Submission"));
        confirmDialog.Content(box_value(hstring(L"Are you sure you want to submit? You have answered ") +
                                        to_hstring(m_answers.size()) + L"/" + to_hstring(m_questions.size()) + L" questions."));
        confirmDialog.PrimaryButtonText(L"Submit");
        confirmDialog.CloseButtonText(L"Cancel");
        confirmDialog.DefaultButton(ContentDialogButton::Close);

        auto result = co_await confirmDialog.ShowAsync();

        if (result == ContentDialogResult::Primary)
        {
            SubmitAttempt();
        }
    }

    void ExamPage::SubmitAttempt()
    {
        if (m_timer)
        {
            m_timer.Stop();
        }

        SaveCurrentAnswer();

        SubmitButton().IsEnabled(false);
        ShowMessage(L"Submitting...", InfoBarSeverity::Informational);

        Windows::Data::Json::JsonArray answersArray;
        for (const auto &q : m_questions)
        {
            Windows::Data::Json::JsonObject answerObj;
            answerObj.Insert(L"question_id", Windows::Data::Json::JsonValue::CreateStringValue(q.question_id));

            auto it = m_answers.find(q.question_id);
            if (it != m_answers.end())
            {
                answerObj.Insert(L"selected_option", Windows::Data::Json::JsonValue::CreateStringValue(it->second));
            }
            else
            {
                answerObj.Insert(L"selected_option", Windows::Data::Json::JsonValue::CreateStringValue(L""));
            }

            answersArray.Append(answerObj);
        }

        int timeSpent = m_timeLimitSeconds - m_timeRemainingSeconds;

        m_supabaseClient->OnAttemptSubmitted = [this](::quiz_examination_system::SupabaseClient::AttemptResult result)
        {
            if (result.success)
            {
                hstring message = hstring(L"Submission successful!\n\n") +
                                  L"Score: " + to_hstring(result.score) + L"/" + to_hstring(result.total_points) + L"\n" +
                                  L"Correct: " + to_hstring(result.correct_count) + L"\n" +
                                  L"Incorrect: " + to_hstring(result.incorrect_count);

                ShowMessage(message, InfoBarSeverity::Success);

                PrevButton().IsEnabled(false);
                NextButton().IsEnabled(false);
                OptionA().IsEnabled(false);
                OptionB().IsEnabled(false);
                OptionC().IsEnabled(false);
                OptionD().IsEnabled(false);
            }
            else
            {
                ShowMessage(hstring(L"Submission error: ") + result.message, InfoBarSeverity::Error);
                SubmitButton().IsEnabled(true);
            }
        };

        m_supabaseClient->SubmitQuizAttempt(m_studentId, m_quizId, answersArray.Stringify(), timeSpent);
    }

    void ExamPage::ShowMessage(hstring const &message, InfoBarSeverity severity)
    {
        MessageBar().Message(message);
        MessageBar().Severity(severity);
        MessageBar().IsOpen(true);
    }
}

</code>

ExamPage.xaml.h:
<code>
#pragma once

#include "ExamPage.g.h"
#include "SupabaseClient.h"
#include <winrt/Windows.Foundation.h>
#include <winrt/Microsoft.UI.Xaml.h>
#include <winrt/Microsoft.UI.Dispatching.h>

namespace winrt::quiz_examination_system::implementation
{
    struct ExamPage : ExamPageT<ExamPage>
    {
        ExamPage();
        ExamPage(hstring const &quizId, hstring const &studentId);

        void SetQuizData(hstring const &quizId, hstring const &studentId)
        {
            m_quizId = quizId;
            m_studentId = studentId;
        }

        void Page_Loaded(winrt::Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);
        void QuestionListView_SelectionChanged(winrt::Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::Controls::SelectionChangedEventArgs const &e);
        void PrevButton_Click(winrt::Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);
        void NextButton_Click(winrt::Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);
        winrt::fire_and_forget SubmitButton_Click(winrt::Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);

    private:
        std::unique_ptr<::quiz_examination_system::SupabaseClient> m_supabaseClient;
        hstring m_quizId;
        hstring m_studentId;
        std::vector<::quiz_examination_system::SupabaseClient::QuestionData> m_questions;
        std::map<hstring, hstring> m_answers;
        int m_currentQuestionIndex{0};
        int m_timeRemainingSeconds{0};
        int m_timeLimitSeconds{0};
        winrt::Microsoft::UI::Dispatching::DispatcherQueueTimer m_timer{nullptr};

        void LoadQuizData();
        void LoadQuestions();
        void DisplayQuestion(int index);
        void SaveCurrentAnswer();
        void StartTimer();
        void UpdateTimerDisplay();
        void SubmitAttempt();
        void ShowMessage(hstring const &message, Microsoft::UI::Xaml::Controls::InfoBarSeverity severity);
    };
}

namespace winrt::quiz_examination_system::factory_implementation
{
    struct ExamPage : ExamPageT<ExamPage, implementation::ExamPage>
    {
    };
}

</code>

MainWindow.xaml.cpp:
<code>
#include "pch.h"
#include "MainWindow.xaml.h"
#include "TeacherDashboardPage.xaml.h"
#include "StudentDashboardPage.xaml.h"
#include "AdminDashboardPage.xaml.h"
#include "SupabaseClientManager.h"
#include "SupabaseClientAsync.h"
#if __has_include("MainWindow.g.cpp")
#include "MainWindow.g.cpp"
#endif

using namespace winrt;
using namespace Microsoft::UI::Xaml;
using namespace Microsoft::UI::Xaml::Controls;

namespace winrt::quiz_examination_system::implementation
{
    MainWindow::MainWindow()
    {
        InitializeComponent();
        m_client = std::make_unique<::quiz_examination_system::SupabaseClientAsync>();

        auto &manager = ::quiz_examination_system::SupabaseClientManager::GetInstance();
        if (manager.HasActiveSession())
        {
            m_authenticated = true;
            m_currentUser = manager.GetUsername();
            m_currentDbRole = manager.GetRole();
            m_currentRole = (m_currentDbRole == L"Admin") ? L"Administrator" : (m_currentDbRole == L"Teacher") ? L"Lecturer"
                                                                                                               : L"Student";
            UpdateView();
        }
    }

    winrt::fire_and_forget MainWindow::Login_Click(IInspectable const &, RoutedEventArgs const &)
    {
        auto lifetime = get_strong();

        auto username = UsernameBox().Text();
        auto password = PasswordBox().Password();

        LoginMessage().IsOpen(false);

        if (username.empty() || password.empty())
        {
            LoginMessage().Message(L"Enter username and password");
            LoginMessage().Severity(InfoBarSeverity::Warning);
            LoginMessage().IsOpen(true);
            co_return;
        }

        LoginButton().IsEnabled(false);
        LoginProgressRing().IsActive(true);
        LoginMessage().Message(L"Signing in...");
        LoginMessage().Severity(InfoBarSeverity::Informational);
        LoginMessage().IsOpen(true);

        try
        {
            auto result = co_await m_client->LoginAsync(username, password);

            if (result.success)
            {
                m_authenticated = true;
                m_currentUser = result.username;
                m_currentUserId = result.userId;
                m_currentDbRole = result.role;
                m_currentRole = result.displayRole;

                auto &manager = ::quiz_examination_system::SupabaseClientManager::GetInstance();
                manager.SaveSession(result.userId, result.username, result.role);

                LoginMessage().IsOpen(false);
                UpdateView();
            }
            else
            {
                LoginMessage().Message(result.errorMessage);
                LoginMessage().Severity(InfoBarSeverity::Error);
                LoginMessage().IsOpen(true);
            }
        }
        catch (hresult_error const &ex)
        {
            LoginMessage().Message(ex.message());
            LoginMessage().Severity(InfoBarSeverity::Error);
            LoginMessage().IsOpen(true);
        }

        LoginButton().IsEnabled(true);
        LoginProgressRing().IsActive(false);
    }

    void MainWindow::Logout_Click(IInspectable const &, RoutedEventArgs const &)
    {
        ContentDialog confirmDialog;
        confirmDialog.XamlRoot(this->Content().XamlRoot());
        confirmDialog.Title(box_value(L"Confirm logout"));
        confirmDialog.Content(box_value(L"Are you sure you want to log out?"));
        confirmDialog.PrimaryButtonText(L"Logout");
        confirmDialog.CloseButtonText(L"Cancel");
        confirmDialog.DefaultButton(ContentDialogButton::Close);

        confirmDialog.PrimaryButtonClick([this](auto &&, auto &&)
                                         {
            auto &manager = ::quiz_examination_system::SupabaseClientManager::GetInstance();
            manager.ClearSession();

            m_authenticated = false;
            m_currentUser = L"";
            m_currentUserId = L"";
            m_currentRole = L"";
            m_currentDbRole = L"";
            LoginMessage().IsOpen(false);
            UpdateView(); });

        confirmDialog.ShowAsync();
    }

    void MainWindow::UpdateView()
    {
        LoginPanel().Visibility(m_authenticated ? Visibility::Collapsed : Visibility::Visible);
        DashboardPanel().Visibility(m_authenticated ? Visibility::Visible : Visibility::Collapsed);

        if (m_authenticated)
        {
            WelcomeText().Text(hstring(L"Welcome, ") + m_currentUser);
            RoleText().Text(hstring(L"(") + m_currentRole + hstring(L")"));

            if (m_currentRole == L"Administrator")
            {
                ContentFrame().Navigate(xaml_typename<quiz_examination_system::AdminDashboardPage>());
            }
            else if (m_currentRole == L"Lecturer")
            {
                ContentFrame().Navigate(xaml_typename<quiz_examination_system::TeacherDashboardPage>());
            }
            else if (m_currentRole == L"Student")
            {
                ContentFrame().Navigate(xaml_typename<quiz_examination_system::StudentDashboardPage>());
            }
        }
        else
        {
            UsernameBox().Text(L"");
            PasswordBox().Password(L"");
        }
    }
}

</code>

MainWindow.xaml.h:
<code>
#pragma once

#include "MainWindow.g.h"
#include "AdminDashboardPage.xaml.h"
#include "TeacherDashboardPage.xaml.h"
#include "StudentDashboardPage.xaml.h"
#include "SupabaseClient.h"
#include <vector>

namespace winrt::quiz_examination_system::implementation
{
    struct MainWindow : MainWindowT<MainWindow>
    {
        MainWindow();

        void Login_Click(IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &);
        void Logout_Click(IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &);
        void ChangePassword_Click(IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &);
        void ManageUsers_Click(IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &);
        void ManageQuestions_Click(IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &);
        void ManageQuizzes_Click(IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &);
        void ReviewAttempts_Click(IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &);
        void TakeQuiz_Click(IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &);
        void DashboardNav_SelectionChanged(IInspectable const &, IInspectable const &);
        void OnClosed(IInspectable const &, Microsoft::UI::Xaml::WindowEventArgs const &);

    private:
        void UpdateView();
        bool ConnectDatabase(hstring const &connectionString);
        void ApplyPermissions(hstring const &role);
        void OnLoginSuccess(hstring username, hstring displayRole, hstring dbRole, hstring userId);
        void OnLoginFailed(hstring message);
        void OnPasswordChanged(hstring message);
        void OnPasswordChangeFailed(hstring message);

        hstring m_connectionString{L"https://tuciofxdzzrzwzqsltps.supabase.co"};
        bool m_dbConnected{false};

        std::unique_ptr<::quiz_examination_system::SupabaseClient> m_supabaseClient;
        bool m_authenticated{false};
        hstring m_currentUser;
        hstring m_currentUserId;
        hstring m_currentRole;
        hstring m_currentDbRole;
        bool m_isClosing{false};
    };
}

namespace winrt::quiz_examination_system::factory_implementation
{
    struct MainWindow : MainWindowT<MainWindow, implementation::MainWindow>
    {
    };
}

</code>

PasswordHasher.h:
<code>
#pragma once

#include <string>
#include <sstream>
#include <iomanip>
#include <array>
#include <random>
#include <winrt/Windows.Security.Cryptography.h>
#include <winrt/Windows.Security.Cryptography.Core.h>
#include <winrt/Windows.Storage.Streams.h>

namespace quiz_examination_system
{
    class PasswordHasher
    {
    private:
        static std::string GenerateSalt()
        {
            const char *charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789./";
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> dis(0, 63);

            std::string salt;
            for (int i = 0; i < 22; ++i)
            {
                salt += charset[dis(gen)];
            }
            return salt;
        }

        static std::string SHA256Hash(const std::string &input, const std::string &salt)
        {
            try
            {
                auto cryptoProvider = winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider::OpenAlgorithm(
                    winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha256());

                std::string saltedInput = salt + input;
                auto buffer = winrt::Windows::Security::Cryptography::CryptographicBuffer::ConvertStringToBinary(
                    winrt::to_hstring(saltedInput),
                    winrt::Windows::Security::Cryptography::BinaryStringEncoding::Utf8);

                auto hashBuffer = cryptoProvider.HashData(buffer);
                auto hashString = winrt::Windows::Security::Cryptography::CryptographicBuffer::EncodeToHexString(hashBuffer);

                return winrt::to_string(hashString);
            }
            catch (...)
            {
                return "";
            }
        }

    public:
        static hstring HashPassword(hstring const &password)
        {
            try
            {
                std::string pwd = winrt::to_string(password);
                std::string salt = GenerateSalt();
                std::string hash = SHA256Hash(pwd, salt);

                if (hash.empty())
                {
                    return L"";
                }

                std::string result = "$2a$10$" + salt.substr(0, 22) + hash.substr(0, 31);
                return winrt::to_hstring(result);
            }
            catch (...)
            {
                return hstring(L"");
            }
        }

        static bool VerifyPassword(hstring const &password, hstring const &storedHash)
        {
            try
            {
                std::string pwd = winrt::to_string(password);
                std::string stored = winrt::to_string(storedHash);

                if (stored.length() < 29 || stored.substr(0, 7) != "$2a$10$")
                {
                    return false;
                }

                std::string salt = stored.substr(7, 22);
                std::string storedHashPart = stored.substr(29);

                std::string computedHash = SHA256Hash(pwd, salt);
                std::string computedHashPart = computedHash.substr(0, 31);

                return computedHashPart == storedHashPart;
            }
            catch (...)
            {
                return false;
            }
        }

        static hstring GetCurrentTimeString()
        {
            auto now = std::chrono::system_clock::now();
            auto time = std::chrono::system_clock::to_time_t(now);
            char buffer[30];
            std::tm tm_struct{};
            localtime_s(&tm_struct, &time);
            strftime(buffer, sizeof(buffer), "%Y-%m-%dT%H:%M:%S", &tm_struct);
            return hstring(winrt::to_hstring(std::string(buffer)));
        }

        static hstring GetLockExpiryTime()
        {
            auto now = std::chrono::system_clock::now();
            auto future = now + std::chrono::minutes(30);
            auto time = std::chrono::system_clock::to_time_t(future);
            char buffer[30];
            std::tm tm_struct{};
            localtime_s(&tm_struct, &time);
            strftime(buffer, sizeof(buffer), "%Y-%m-%dT%H:%M:%S", &tm_struct);
            return hstring(winrt::to_hstring(std::string(buffer)));
        }
    };
}

</code>

pch.cpp:
<code>
#include "pch.h"

</code>

pch.h:
<code>
#pragma once
#include <windows.h>
#include <unknwn.h>
#include <restrictederrorinfo.h>
#include <hstring.h>

#undef GetCurrentTime

#include <winrt/Windows.Foundation.h>
#include <winrt/Windows.Foundation.Collections.h>
#include <winrt/Windows.ApplicationModel.Activation.h>
#include <winrt/Microsoft.UI.Composition.h>
#include <winrt/Microsoft.UI.Xaml.h>
#include <winrt/Microsoft.UI.Xaml.Controls.h>
#include <winrt/Microsoft.UI.Xaml.Controls.Primitives.h>
#include <winrt/Microsoft.UI.Xaml.Data.h>
#include <winrt/Microsoft.UI.Xaml.Interop.h>
#include <winrt/Microsoft.UI.Xaml.Markup.h>
#include <winrt/Microsoft.UI.Xaml.Media.h>
#include <winrt/Microsoft.UI.Xaml.Navigation.h>
#include <winrt/Microsoft.UI.Xaml.Shapes.h>
#include <winrt/Microsoft.UI.Dispatching.h>
#include <wil/cppwinrt_helpers.h>

#include "QuestionItem.h"

</code>

QuestionBankPage.xaml.cpp:
<code>
#include "pch.h"
#include "QuestionBankPage.xaml.h"
#if __has_include("QuestionBankPage.g.cpp")
#include "QuestionBankPage.g.cpp"
#endif

using namespace winrt;
using namespace Microsoft::UI::Xaml;
using namespace Microsoft::UI::Xaml::Controls;

namespace winrt::quiz_examination_system::implementation
{
    QuestionBankPage::QuestionBankPage()
    {
        InitializeComponent();
        m_questions = single_threaded_observable_vector<quiz_examination_system::QuestionItem>();
        m_client = std::make_unique<::quiz_examination_system::SupabaseClientAsync>();
    }

    void QuestionBankPage::Page_Loaded(Windows::Foundation::IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &)
    {
        LoadQuestions();
    }

    winrt::fire_and_forget QuestionBankPage::LoadQuestions()
    {
        auto lifetime = get_strong();

        LoadingRing().IsActive(true);

        auto &manager = ::quiz_examination_system::SupabaseClientManager::GetInstance();
        auto teacherId = manager.GetUserId();

        try
        {
            auto questionsJson = co_await m_client->GetQuestionsJsonAsync(teacherId);

            m_questions.Clear();
            auto questionsArray = Windows::Data::Json::JsonArray::Parse(questionsJson);

            for (uint32_t i = 0; i < questionsArray.Size(); ++i)
            {
                auto qObj = questionsArray.GetObjectAt(i);

                auto item = make<QuestionItem>();
                item.QuestionId(qObj.GetNamedString(L"id", L""));
                item.QuestionText(qObj.GetNamedString(L"question_text", L""));
                item.DifficultyLevel(qObj.GetNamedString(L"difficulty_level", L"medium"));
                item.Topic(qObj.GetNamedString(L"topic", L"General"));

                m_questions.Append(item);
            }

            QuestionListView().ItemsSource(m_questions);
        }
        catch (hresult_error const &ex)
        {
            ShowMessage(ex.message(), InfoBarSeverity::Error);
        }

        LoadingRing().IsActive(false);
    }

    void QuestionBankPage::AddQuestion_Click(Windows::Foundation::IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &)
    {
        ShowAddQuestionDialog();
    }

    winrt::fire_and_forget QuestionBankPage::ShowAddQuestionDialog()
    {
        auto lifetime = get_strong();

        InputQuestionText().Text(L"");
        InputOptionA().Text(L"");
        InputOptionB().Text(L"");
        InputOptionC().Text(L"");
        InputOptionD().Text(L"");
        InputTopic().Text(L"");
        ComboCorrectOption().SelectedIndex(0);
        ComboDifficulty().SelectedIndex(1);

        auto result = co_await AddQuestionDialog().ShowAsync();

        if (result == ContentDialogResult::Primary)
        {
            auto qText = InputQuestionText().Text();
            auto optA = InputOptionA().Text();
            auto optB = InputOptionB().Text();
            auto optC = InputOptionC().Text();
            auto optD = InputOptionD().Text();
            auto topic = InputTopic().Text();

            if (qText.empty() || optA.empty() || optB.empty() || optC.empty() || optD.empty())
            {
                ShowMessage(L"Question text and all 4 options are required", InfoBarSeverity::Warning);
                co_return;
            }

            std::set<std::wstring> uniqueOptions = {
                std::wstring(optA),
                std::wstring(optB),
                std::wstring(optC),
                std::wstring(optD)};

            if (uniqueOptions.size() != 4)
            {
                ShowMessage(L"All 4 options must be unique", InfoBarSeverity::Warning);
                co_return;
            }

            auto correctOpt = unbox_value<hstring>(ComboCorrectOption().SelectedItem().as<ComboBoxItem>().Content());
            auto difficulty = unbox_value<hstring>(ComboDifficulty().SelectedItem().as<ComboBoxItem>().Content());

            auto &manager = ::quiz_examination_system::SupabaseClientManager::GetInstance();
            auto teacherId = manager.GetUserId();

            hstring questionId = to_hstring(std::chrono::system_clock::now().time_since_epoch().count() % 1000000);

            try
            {
                auto createResult = co_await m_client->CreateQuestionValidatedAsync(
                    questionId, teacherId, qText, optA, optB, optC, optD, correctOpt, difficulty, topic);

                if (createResult.success)
                {
                    ShowMessage(L"Question created successfully", InfoBarSeverity::Success);
                    LoadQuestions();
                }
                else
                {
                    ShowMessage(createResult.message, InfoBarSeverity::Error);
                }
            }
            catch (hresult_error const &ex)
            {
                ShowMessage(ex.message(), InfoBarSeverity::Error);
            }
        }
    }

    void QuestionBankPage::ImportQuestions_Click(Windows::Foundation::IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &)
    {
        ShowMessage(L"Import feature not implemented yet", InfoBarSeverity::Informational);
    }

    void QuestionBankPage::RefreshQuestions_Click(Windows::Foundation::IInspectable const &, Microsoft::UI::Xaml::RoutedEventArgs const &)
    {
        LoadQuestions();
    }

    void QuestionBankPage::EditQuestion_Click(Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &)
    {
        auto btn = sender.as<Button>();
        auto questionId = unbox_value<hstring>(btn.Tag());
        ShowMessage(hstring(L"Edit question: ") + questionId + L" (not implemented)", InfoBarSeverity::Informational);
    }

    winrt::fire_and_forget QuestionBankPage::DeleteQuestion_Click(Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &)
    {
        auto lifetime = get_strong();

        auto btn = sender.as<Button>();
        auto questionId = unbox_value<hstring>(btn.Tag());

        ContentDialog confirmDialog;
        confirmDialog.XamlRoot(this->XamlRoot());
        confirmDialog.Title(box_value(L"Confirm deletion"));
        confirmDialog.Content(box_value(hstring(L"Are you sure you want to delete this question?")));
        confirmDialog.PrimaryButtonText(L"Delete");
        confirmDialog.CloseButtonText(L"Cancel");
        confirmDialog.DefaultButton(ContentDialogButton::Close);

        auto result = co_await confirmDialog.ShowAsync();

        if (result == ContentDialogResult::Primary)
        {
            try
            {
                bool success = co_await m_client->DeleteQuestionSafeAsync(questionId);

                if (success)
                {
                    ShowMessage(L"Question deleted successfully", InfoBarSeverity::Success);
                    LoadQuestions();
                }
                else
                {
                    ShowMessage(L"Failed to delete question", InfoBarSeverity::Error);
                }
            }
            catch (hresult_error const &ex)
            {
                ShowMessage(ex.message(), InfoBarSeverity::Error);
            }
        }
    }

    void QuestionBankPage::ShowMessage(hstring const &message, Microsoft::UI::Xaml::Controls::InfoBarSeverity severity)
    {
        ActionMessage().Message(message);
        ActionMessage().Severity(severity);
        ActionMessage().IsOpen(true);
    }
}

</code>

QuestionBankPage.xaml.h:
<code>
#pragma once

#include "QuestionBankPage.g.h"
#include "QuestionItem.h"
#include "SupabaseClientAsync.h"
#include "SupabaseClientManager.h"
#include <winrt/Windows.Foundation.Collections.h>

namespace winrt::quiz_examination_system::implementation
{
    struct QuestionBankPage : QuestionBankPageT<QuestionBankPage>
    {
        QuestionBankPage();

        void Page_Loaded(Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);
        void AddQuestion_Click(Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);
        void ImportQuestions_Click(Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);
        void RefreshQuestions_Click(Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);
        void EditQuestion_Click(Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);
        void DeleteQuestion_Click(Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);

    private:
        Windows::Foundation::Collections::IObservableVector<quiz_examination_system::QuestionItem> m_questions;
        std::unique_ptr<::quiz_examination_system::SupabaseClientAsync> m_client;

        winrt::fire_and_forget LoadQuestions();
        winrt::fire_and_forget ShowAddQuestionDialog();
        void ShowMessage(hstring const &message, Microsoft::UI::Xaml::Controls::InfoBarSeverity severity);
    };
}

namespace winrt::quiz_examination_system::factory_implementation
{
    struct QuestionBankPage : QuestionBankPageT<QuestionBankPage, implementation::QuestionBankPage>
    {
    };
}

</code>

QuestionItem.cpp:
<code>
#include "pch.h"
#include "QuestionItem.h"
#if __has_include("QuestionItem.g.cpp")
#include "QuestionItem.g.cpp"
#endif

using namespace winrt;
using namespace Microsoft::UI::Xaml::Data;

namespace winrt::quiz_examination_system::implementation
{
    hstring QuestionItem::QuestionId()
    {
        return m_questionId;
    }

    void QuestionItem::QuestionId(hstring const &value)
    {
        if (m_questionId != value)
        {
            m_questionId = value;
            m_propertyChanged(*this, PropertyChangedEventArgs(L"QuestionId"));
        }
    }

    hstring QuestionItem::QuestionText()
    {
        return m_questionText;
    }

    void QuestionItem::QuestionText(hstring const &value)
    {
        if (m_questionText != value)
        {
            m_questionText = value;
            m_propertyChanged(*this, PropertyChangedEventArgs(L"QuestionText"));
        }
    }

    hstring QuestionItem::DifficultyLevel()
    {
        return m_difficultyLevel;
    }

    void QuestionItem::DifficultyLevel(hstring const &value)
    {
        if (m_difficultyLevel != value)
        {
            m_difficultyLevel = value;
            m_propertyChanged(*this, PropertyChangedEventArgs(L"DifficultyLevel"));
        }
    }

    hstring QuestionItem::Topic()
    {
        return m_topic;
    }

    void QuestionItem::Topic(hstring const &value)
    {
        if (m_topic != value)
        {
            m_topic = value;
            m_propertyChanged(*this, PropertyChangedEventArgs(L"Topic"));
        }
    }

    winrt::event_token QuestionItem::PropertyChanged(PropertyChangedEventHandler const &handler)
    {
        return m_propertyChanged.add(handler);
    }

    void QuestionItem::PropertyChanged(winrt::event_token const &token) noexcept
    {
        m_propertyChanged.remove(token);
    }
}

</code>

QuestionItem.h:
<code>
#pragma once

#include "QuestionItem.g.h"

namespace winrt::quiz_examination_system::implementation
{
    struct QuestionItem : QuestionItemT<QuestionItem>
    {
        QuestionItem() = default;

        hstring QuestionId();
        void QuestionId(hstring const &value);

        hstring QuestionText();
        void QuestionText(hstring const &value);

        hstring DifficultyLevel();
        void DifficultyLevel(hstring const &value);

        hstring Topic();
        void Topic(hstring const &value);

        winrt::event_token PropertyChanged(Microsoft::UI::Xaml::Data::PropertyChangedEventHandler const &handler);
        void PropertyChanged(winrt::event_token const &token) noexcept;

    private:
        hstring m_questionId;
        hstring m_questionText;
        hstring m_difficultyLevel;
        hstring m_topic;

        winrt::event<Microsoft::UI::Xaml::Data::PropertyChangedEventHandler> m_propertyChanged;
    };
}

namespace winrt::quiz_examination_system::factory_implementation
{
    struct QuestionItem : QuestionItemT<QuestionItem, implementation::QuestionItem>
    {
    };
}

</code>

QuizItemStudent.cpp:
<code>
#include "pch.h"
#include "QuizItemStudent.h"
#include "QuizItemStudent.g.cpp"

namespace winrt::quiz_examination_system::implementation
{
    hstring QuizItemStudent::QuizId()
    {
        return m_quizId;
    }

    void QuizItemStudent::QuizId(hstring const &value)
    {
        if (m_quizId != value)
        {
            m_quizId = value;
            m_propertyChanged(*this, Microsoft::UI::Xaml::Data::PropertyChangedEventArgs{L"QuizId"});
        }
    }

    hstring QuizItemStudent::Title()
    {
        return m_title;
    }

    void QuizItemStudent::Title(hstring const &value)
    {
        if (m_title != value)
        {
            m_title = value;
            m_propertyChanged(*this, Microsoft::UI::Xaml::Data::PropertyChangedEventArgs{L"Title"});
        }
    }

    int32_t QuizItemStudent::TimeLimit()
    {
        return m_timeLimit;
    }

    void QuizItemStudent::TimeLimit(int32_t value)
    {
        if (m_timeLimit != value)
        {
            m_timeLimit = value;
            m_propertyChanged(*this, Microsoft::UI::Xaml::Data::PropertyChangedEventArgs{L"TimeLimit"});
        }
    }

    int32_t QuizItemStudent::TotalPoints()
    {
        return m_totalPoints;
    }

    void QuizItemStudent::TotalPoints(int32_t value)
    {
        if (m_totalPoints != value)
        {
            m_totalPoints = value;
            m_propertyChanged(*this, Microsoft::UI::Xaml::Data::PropertyChangedEventArgs{L"TotalPoints"});
        }
    }

    int32_t QuizItemStudent::AttemptsUsed()
    {
        return m_attemptsUsed;
    }

    void QuizItemStudent::AttemptsUsed(int32_t value)
    {
        if (m_attemptsUsed != value)
        {
            m_attemptsUsed = value;
            m_propertyChanged(*this, Microsoft::UI::Xaml::Data::PropertyChangedEventArgs{L"AttemptsUsed"});
        }
    }

    hstring QuizItemStudent::MaxAttempts()
    {
        return m_maxAttempts;
    }

    void QuizItemStudent::MaxAttempts(hstring const &value)
    {
        if (m_maxAttempts != value)
        {
            m_maxAttempts = value;
            m_propertyChanged(*this, Microsoft::UI::Xaml::Data::PropertyChangedEventArgs{L"MaxAttempts"});
        }
    }

    hstring QuizItemStudent::Status()
    {
        return m_status;
    }

    void QuizItemStudent::Status(hstring const &value)
    {
        if (m_status != value)
        {
            m_status = value;
            m_propertyChanged(*this, Microsoft::UI::Xaml::Data::PropertyChangedEventArgs{L"Status"});
        }
    }

    winrt::event_token QuizItemStudent::PropertyChanged(Microsoft::UI::Xaml::Data::PropertyChangedEventHandler const &handler)
    {
        return m_propertyChanged.add(handler);
    }

    void QuizItemStudent::PropertyChanged(winrt::event_token const &token) noexcept
    {
        m_propertyChanged.remove(token);
    }
}

</code>

QuizItemStudent.h:
<code>
#pragma once

#include "QuizItemStudent.g.h"

namespace winrt::quiz_examination_system::implementation
{
    struct QuizItemStudent : QuizItemStudentT<QuizItemStudent>
    {
        QuizItemStudent() = default;

        hstring QuizId();
        void QuizId(hstring const &value);

        hstring Title();
        void Title(hstring const &value);

        int32_t TimeLimit();
        void TimeLimit(int32_t value);

        int32_t TotalPoints();
        void TotalPoints(int32_t value);

        int32_t AttemptsUsed();
        void AttemptsUsed(int32_t value);

        hstring MaxAttempts();
        void MaxAttempts(hstring const &value);

        hstring Status();
        void Status(hstring const &value);

        winrt::event_token PropertyChanged(Microsoft::UI::Xaml::Data::PropertyChangedEventHandler const &handler);
        void PropertyChanged(winrt::event_token const &token) noexcept;

    private:
        hstring m_quizId;
        hstring m_title;
        int32_t m_timeLimit{0};
        int32_t m_totalPoints{0};
        int32_t m_attemptsUsed{0};
        hstring m_maxAttempts;
        hstring m_status;

        winrt::event<Microsoft::UI::Xaml::Data::PropertyChangedEventHandler> m_propertyChanged;
    };
}

namespace winrt::quiz_examination_system::factory_implementation
{
    struct QuizItemStudent : QuizItemStudentT<QuizItemStudent, implementation::QuizItemStudent>
    {
    };
}

</code>

StudentDashboardPage.xaml.cpp:
<code>
#include "pch.h"
#include "StudentDashboardPage.xaml.h"
#include "ExamPage.xaml.h"
#include "QuizItemStudent.h"
#if __has_include("StudentDashboardPage.g.cpp")
#include "StudentDashboardPage.g.cpp"
#endif

using namespace winrt;
using namespace Microsoft::UI::Xaml;
using namespace Microsoft::UI::Xaml::Controls;

namespace winrt::quiz_examination_system::implementation
{
    StudentDashboardPage::StudentDashboardPage()
    {
        InitializeComponent();
        m_quizzes = single_threaded_observable_vector<quiz_examination_system::QuizItemStudent>();
        m_supabaseClient = std::make_unique<::quiz_examination_system::SupabaseClient>();
        m_currentUserId = L"";
    }

    Windows::Foundation::Collections::IObservableVector<quiz_examination_system::QuizItemStudent> StudentDashboardPage::Quizzes()
    {
        return m_quizzes;
    }

    void StudentDashboardPage::Page_Loaded(IInspectable const &, RoutedEventArgs const &)
    {
        LoadQuizzes();
    }

    void StudentDashboardPage::LoadQuizzes()
    {
        if (!m_supabaseClient)
        {
            ShowMessage(L"Error: Cannot connect to database", InfoBarSeverity::Error);
            return;
        }

        LoadingRing().IsActive(true);
        ShowMessage(L"Loading quiz list...", InfoBarSeverity::Informational);

        auto dispatcher = Microsoft::UI::Dispatching::DispatcherQueue::GetForCurrentThread();

        m_supabaseClient->OnStudentQuizzesLoaded = [this, dispatcher](bool success, std::vector<::quiz_examination_system::SupabaseClient::QuizData> quizzes)
        {
            dispatcher.TryEnqueue([this, success, quizzes]()
                                  {
                LoadingRing().IsActive(false);
                ActionMessage().IsOpen(false);

                if (!success)
                {
                    ShowMessage(L"Failed to load quiz list", InfoBarSeverity::Error);
                    return;
                }

                if (quizzes.empty())
                {
                    ShowMessage(L"No quizzes assigned to you yet", InfoBarSeverity::Warning);
                    return;
                }

                m_quizzes.Clear();

                for (const auto &quiz : quizzes)
                {
                    auto item = make<QuizItemStudent>();
                    item.QuizId(quiz.quiz_id);
                    item.Title(quiz.quiz_title);
                    item.TimeLimit(quiz.time_limit_minutes);
                    item.TotalPoints(quiz.total_points);
                    item.AttemptsUsed(quiz.attempts_used);
                    item.MaxAttempts(quiz.max_attempts);
                    item.Status(L"Available");

                    m_quizzes.Append(item);
                }

                ShowMessage(hstring(L"Loaded ") + to_hstring(quizzes.size()) + L" quizzes", InfoBarSeverity::Success); });
        };

        m_supabaseClient->GetStudentQuizzes(m_currentUserId);
    }

    void StudentDashboardPage::QuizzesGridView_SelectionChanged(IInspectable const &, SelectionChangedEventArgs const &)
    {
        int index = QuizzesGridView().SelectedIndex();
        if (index >= 0 && index < static_cast<int>(m_quizzes.Size()))
        {
            m_selectedQuiz = m_quizzes.GetAt(index);
            StartExamButton().IsEnabled(true);
        }
        else
        {
            StartExamButton().IsEnabled(false);
        }
    }

    void StudentDashboardPage::StartExam_Click(IInspectable const &, RoutedEventArgs const &)
    {
        if (!m_selectedQuiz || m_selectedQuiz.QuizId().empty())
        {
            ShowMessage(L"Please select a quiz", InfoBarSeverity::Warning);
            return;
        }

        if (m_selectedQuiz.MaxAttempts() != L"unlimited")
        {
            int maxAttempts = std::stoi(m_selectedQuiz.MaxAttempts().c_str());
            if (m_selectedQuiz.AttemptsUsed() >= maxAttempts)
            {
                ShowMessage(L"You have reached the maximum attempts for this quiz", InfoBarSeverity::Error);
                return;
            }
        }

        TypeName examType;
        examType.Name = L"quiz_examination_system.ExamPage";
        examType.Kind = TypeKind::Metadata;
        Frame().Navigate(examType);

        auto page = Frame().Content().try_as<quiz_examination_system::ExamPage>();
        if (page)
        {
            page.as<quiz_examination_system::implementation::ExamPage>()->SetQuizData(m_selectedQuiz.QuizId(), m_currentUserId);
        }
    }

    void StudentDashboardPage::ShowMessage(hstring const &message, InfoBarSeverity severity)
    {
        ActionMessage().Message(message);
        ActionMessage().Severity(severity);
        ActionMessage().IsOpen(true);
    }
}

</code>

StudentDashboardPage.xaml.h:
<code>
#pragma once

#include "StudentDashboardPage.g.h"
#include "QuizItemStudent.h"
#include "SupabaseClient.h"
#include <winrt/Windows.Foundation.h>
#include <winrt/Microsoft.UI.Xaml.h>
#include <winrt/Windows.Foundation.Collections.h>

namespace winrt::quiz_examination_system::implementation
{
    struct StudentDashboardPage : StudentDashboardPageT<StudentDashboardPage>
    {
        StudentDashboardPage();

        Windows::Foundation::Collections::IObservableVector<quiz_examination_system::QuizItemStudent> Quizzes();

        void SetStudentId(hstring const &studentId) { m_currentUserId = studentId; }

        void Page_Loaded(winrt::Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);
        void QuizzesGridView_SelectionChanged(winrt::Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::Controls::SelectionChangedEventArgs const &e);
        void StartExam_Click(winrt::Windows::Foundation::IInspectable const &sender, Microsoft::UI::Xaml::RoutedEventArgs const &e);

    private:
        std::unique_ptr<::quiz_examination_system::SupabaseClient> m_supabaseClient;
        Windows::Foundation::Collections::IObservableVector<quiz_examination_system::QuizItemStudent> m_quizzes{nullptr};
        quiz_examination_system::QuizItemStudent m_selectedQuiz{nullptr};
        hstring m_currentUserId;

        void LoadQuizzes();
        void ShowMessage(hstring const &message, Microsoft::UI::Xaml::Controls::InfoBarSeverity severity);
    };
}

namespace winrt::quiz_examination_system::factory_implementation
{
    struct StudentDashboardPage : StudentDashboardPageT<StudentDashboardPage, implementation::StudentDashboardPage>
    {
    };
}

</code>

SupabaseClient.cpp:
<code>
#include "pch.h"
#include "SupabaseClient.h"
#include "BCryptPasswordHasher.h"
#include <winrt/Windows.Web.Http.Filters.h>
#include <winrt/Microsoft.UI.Dispatching.h>

using namespace winrt;
using namespace Windows::Foundation;
using namespace Windows::Web::Http;
using namespace Windows::Web::Http::Filters;
using namespace Windows::Data::Json;
using namespace Microsoft::UI::Dispatching;

namespace quiz_examination_system
{
    SupabaseClient::SupabaseClient()
    {
        HttpBaseProtocolFilter filter;
        m_httpClient = HttpClient(filter);
    }

    void SupabaseClient::Login(hstring const &username, hstring const &password)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            // Step 1: Check account status (locked, inactive, or active)
            JsonObject statusParams;
            statusParams.Insert(L"input_username", JsonValue::CreateStringValue(username));
            Uri statusUri(m_projectUrl + L"/rest/v1/rpc/check_account_status");
            HttpRequestMessage statusReq(HttpMethod::Post(), statusUri);
            statusReq.Headers().Insert(L"apikey", m_anonKey);
            statusReq.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            statusReq.Content(HttpStringContent(statusParams.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            auto statusOp = m_httpClient.SendRequestAsync(statusReq);
            statusOp.Completed([this, username, password, dispatcher](auto op, auto status)
                               {
                if (status == AsyncStatus::Completed)
                {
                    try
                    {
                        auto statusResponse = op.GetResults();
                        statusResponse.Content().ReadAsStringAsync().Completed([this, username, password, dispatcher](auto readOp, auto readStatus)
                                                                               {
                            UNREFERENCED_PARAMETER(readStatus);
                            dispatcher.TryEnqueue([this, username, password, dispatcher, readOp]()
                                                                                                       {
                                try
                                {
                                    auto statusContent = readOp.GetResults();
                                    auto statusObj = JsonObject::Parse(statusContent);
                                    auto checkStatus = statusObj.GetNamedString(L"status", L"");
                                        
                                    if (checkStatus == L"user_not_found")
                                    {
                                        if (OnLoginFailed)
                                        {
                                            OnLoginFailed(L"User not found");
                                        }
                                        return;
                                    }
                                    else if (checkStatus == L"locked")
                                    {
                                        auto minutesRemaining = static_cast<int>(statusObj.GetNamedNumber(L"minutes_remaining", 30));
                                        hstring message = hstring(L"Account is locked. Try again in ") + to_hstring(minutesRemaining) + L" minutes.";
                                        if (OnLoginFailed)
                                        {
                                            OnLoginFailed(message);
                                        }
                                        return;
                                    }
                                    else if (checkStatus == L"inactive")
                                    {
                                        if (OnLoginFailed)
                                        {
                                            OnLoginFailed(L"Account is inactive");
                                        }
                                        return;
                                    }
                                    
                                    // Step 2: Account is active, proceed with login
                                    Uri uri(m_projectUrl + L"/rest/v1/users?select=id,username,password_hash,role,failed_login_count,locked_until&username=eq." + username);
                                    HttpRequestMessage request(HttpMethod::Get(), uri);
                                    request.Headers().Insert(L"apikey", m_anonKey);
                                    request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);

                                    m_httpClient.SendRequestAsync(request).Completed([this, username, password, dispatcher](auto const &asyncOp, auto)
                                    {
                                        try
                                        {
                                            auto response = asyncOp.GetResults();
                                            if (response.StatusCode() == HttpStatusCode::Ok)
                                            {
                                                response.Content().ReadAsStringAsync().Completed([this, username, password, dispatcher](auto const &readOp, auto)
                                                {
                                                    dispatcher.TryEnqueue([this, username, password, dispatcher, readOp]()
                                                    {
                                                        try
                                                        {
                                                            auto content = readOp.GetResults();
                                                            JsonArray users = JsonArray::Parse(content);
                                                            
                                                            if (users.Size() > 0)
                                                            {
                                                                auto user = users.GetObjectAt(0);
                                                                auto userId = user.GetNamedString(L"id");
                                                                auto storedHash = user.GetNamedString(L"password_hash");
                                                                auto role = user.GetNamedString(L"role", L"Student");

                                                                if (BCryptPasswordHasher::VerifyPassword(password, storedHash))
                                                                {
                                                                    // Password correct - reset failed login count via RPC
                                                                    JsonObject resetParams;
                                                                    resetParams.Insert(L"input_username", JsonValue::CreateStringValue(username));
                                                                    Uri resetUri(m_projectUrl + L"/rest/v1/rpc/handle_login_success");
                                                                    HttpRequestMessage resetReq(HttpMethod::Post(), resetUri);
                                                                    resetReq.Headers().Insert(L"apikey", m_anonKey);
                                                                    resetReq.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
                                                                    resetReq.Content(HttpStringContent(resetParams.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));
                                                                    
                                                                    m_httpClient.SendRequestAsync(resetReq);
                                                                    
                                                                    hstring displayRole = (role == L"Admin") ? L"Administrator" : 
                                                                                         (role == L"Teacher") ? L"Lecturer" : L"Student";
                                                                    if (OnLoginSuccess)
                                                                    {
                                                                        OnLoginSuccess(username, displayRole, role, userId);
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    // Password wrong - increment failed login count via RPC
                                                                    JsonObject rpcParams;
                                                                    rpcParams.Insert(L"input_username", JsonValue::CreateStringValue(username));
                                                                    Uri rpcUri(m_projectUrl + L"/rest/v1/rpc/handle_login_failure");
                                                                    HttpRequestMessage rpcReq(HttpMethod::Post(), rpcUri);
                                                                    rpcReq.Headers().Insert(L"apikey", m_anonKey);
                                                                    rpcReq.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
                                                                    rpcReq.Content(HttpStringContent(rpcParams.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));
                                                                    
                                                                    auto rpcOp = m_httpClient.SendRequestAsync(rpcReq);
                                                                    rpcOp.Completed([this, dispatcher](auto op, auto status)
                                                                    {
                                                                        if (status == AsyncStatus::Completed)
                                                                        {
                                                                            try
                                                                            {
                                                                                auto rpcResponse = op.GetResults();
                                                                                rpcResponse.Content().ReadAsStringAsync().Completed([this, dispatcher](auto readOp, auto readStatus)
                                                                                {
                                                                                    UNREFERENCED_PARAMETER(readStatus);
                                                                                    dispatcher.TryEnqueue([this, dispatcher, readOp]()
                                                                                    {
                                                                                        try
                                                                                        {
                                                                                            auto rpcContent = readOp.GetResults();
                                                                                            auto resultObj = JsonObject::Parse(rpcContent);
                                                                                            auto rpcStatus = resultObj.GetNamedString(L"status", L"");
                                                                                            
                                                                                            if (rpcStatus == L"locked")
                                                                                            {
                                                                                                auto message = resultObj.GetNamedString(L"message", L"Account locked");
                                                                                                if (OnLoginFailed)
                                                                                                {
                                                                                                    OnLoginFailed(message);
                                                                                                }
                                                                                            }
                                                                                            else if (rpcStatus == L"failed")
                                                                                            {
                                                                                                int attemptsLeft = static_cast<int>(resultObj.GetNamedNumber(L"attempts_left", 4));
                                                                                                hstring message = hstring(L"Invalid credentials. Attempts left: ") + to_hstring(attemptsLeft);
                                                                                                if (OnLoginFailed)
                                                                                                {
                                                                                                    OnLoginFailed(message);
                                                                                                }
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                                if (OnLoginFailed)
                                                                                                {
                                                                                                    OnLoginFailed(L"Invalid credentials. Please check your username and password.");
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        catch (...)
                                                                                        {
                                                                                            if (OnLoginFailed)
                                                                                            {
                                                                                                OnLoginFailed(L"Invalid credentials");
                                                                                            }
                                                                                        }
                                                                                    });
                                                                                });
                                                                            }
                                                                            catch (...)
                                                                            {
                                                                                dispatcher.TryEnqueue([this]()
                                                                                {
                                                                                    if (OnLoginFailed)
                                                                                    {
                                                                                        OnLoginFailed(L"Invalid credentials");
                                                                                    }
                                                                                });
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            dispatcher.TryEnqueue([this]()
                                                                            {
                                                                                if (OnLoginFailed)
                                                                                {
                                                                                    OnLoginFailed(L"Login failed");
                                                                                }
                                                                            });
                                                                        }
                                                                    });
                                                                }
                                                            }
                                                            else
                                                            {
                                                                if (OnLoginFailed)
                                                                {
                                                                    OnLoginFailed(L"User not found");
                                                                }
                                                            }
                                                        }
                                                        catch (...)
                                                        {
                                                            if (OnLoginFailed)
                                                            {
                                                                OnLoginFailed(L"Parse error");
                                                            }
                                                        }
                                                    });
                                                });
                                            }
                                            else
                                            {
                                                dispatcher.TryEnqueue([this, response]()
                                                {
                                                    if (OnLoginFailed)
                                                    {
                                                        OnLoginFailed(hstring(L"API error: ") + to_hstring(static_cast<int>(response.StatusCode())));
                                                    }
                                                });
                                            }
                                        }
                                        catch (...)
                                        {
                                            dispatcher.TryEnqueue([this]()
                                            {
                                                if (OnLoginFailed)
                                                {
                                                    OnLoginFailed(L"Request error");
                                                }
                                            });
                                        }
                                    });
                }  
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnLoginFailed)
                        {
                            OnLoginFailed(L"Status check error");
                        }
                    });
                }
            });
                    });
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                                          {
                            if (OnLoginFailed)
                            {
                                OnLoginFailed(L"Status check failed");
                            } });
                }
                } });
        }
        catch (...)
        {
            if (OnLoginFailed)
            {
                OnLoginFailed(L"Connection error");
            }
        }
    }

    void SupabaseClient::ChangePassword(hstring const &username, hstring const &currentPassword, hstring const &newPassword)
    {
        try
        {
            if (newPassword.size() > 72)
            {
                auto dispatcher = DispatcherQueue::GetForCurrentThread();
                dispatcher.TryEnqueue([this]()
                                      {
                    if (OnPasswordChangeFailed)
                    {
                        OnPasswordChangeFailed(L"Password must not exceed 72 bytes");
                    } });
                return;
            }

            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            Uri uri(m_projectUrl + L"/rest/v1/users?select=id,username,password_hash,role&username=eq." + username);
            HttpRequestMessage request(HttpMethod::Get(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);

            m_httpClient.SendRequestAsync(request).Completed([this, currentPassword, newPassword, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, currentPassword, newPassword, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([=]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    JsonArray users = JsonArray::Parse(content);
                                    
                                    if (users.Size() > 0)
                                    {
                                        auto user = users.GetObjectAt(0);
                                        auto storedHash = user.GetNamedString(L"password_hash");
                                        auto userId = user.GetNamedString(L"id");
                                        
                                        if (storedHash == currentPassword)
                                        {
                                            JsonObject updateData;
                                            updateData.Insert(L"password_hash", JsonValue::CreateStringValue(newPassword));
                                            
                                            Uri updateUri(m_projectUrl + L"/rest/v1/users?id=eq." + userId);
                                            HttpRequestMessage updateRequest(HttpMethod::Patch(), updateUri);
                                            updateRequest.Headers().Insert(L"apikey", m_anonKey);
                                            updateRequest.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
                                            updateRequest.Headers().Insert(L"Content-Type", L"application/json");
                                            updateRequest.Content(HttpStringContent(updateData.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

                                            m_httpClient.SendRequestAsync(updateRequest).Completed([=](auto const &updateOp, auto)
                                            {
                                                dispatcher.TryEnqueue([=]()
                                                {
                                                    try
                                                    {
                                                        auto updateResponse = updateOp.GetResults();
                                                        if (updateResponse.StatusCode() == HttpStatusCode::NoContent || updateResponse.StatusCode() == HttpStatusCode::Ok)
                                                        {
                                                            if (OnPasswordChanged)
                                                            {
                                                                OnPasswordChanged(L"Password updated");
                                                            }
                                                        }
                                                        else
                                                        {
                                                            if (OnPasswordChangeFailed)
                                                            {
                                                                OnPasswordChangeFailed(L"Update failed");
                                                            }
                                                        }
                                                    }
                                                    catch (...)
                                                    {
                                                        if (OnPasswordChangeFailed)
                                                        {
                                                            OnPasswordChangeFailed(L"Update error");
                                                        }
                                                    }
                                                });
                                            });
                                        }
                                        else
                                        {
                                            if (OnPasswordChangeFailed)
                                            {
                                                OnPasswordChangeFailed(L"Current password is incorrect");
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (OnPasswordChangeFailed)
                                        {
                                            OnPasswordChangeFailed(L"User not found");
                                        }
                                    }
                                }
                                catch (...)
                                {
                                    if (OnPasswordChangeFailed)
                                    {
                                        OnPasswordChangeFailed(L"Parse error");
                                    }
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([=]()
                        {
                            if (OnPasswordChangeFailed)
                            {
                                OnPasswordChangeFailed(L"Database error");
                            }
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([=]()
                    {
                        if (OnPasswordChangeFailed)
                        {
                            OnPasswordChangeFailed(L"Request error");
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnPasswordChangeFailed)
            {
                OnPasswordChangeFailed(L"Connection error");
            }
        }
    }

    void SupabaseClient::CreateUser(hstring const &username, hstring const &password, hstring const &role, hstring const &createdBy)
    {
        try
        {
            if (password.size() > 72)
            {
                auto dispatcher = DispatcherQueue::GetForCurrentThread();
                dispatcher.TryEnqueue([this]()
                                      {
                    if (OnUserCreationFailed)
                        OnUserCreationFailed(L"Password must not exceed 72 bytes"); });
                return;
            }

            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            JsonObject newUser;
            newUser.Insert(L"username", JsonValue::CreateStringValue(username));
            newUser.Insert(L"password_hash", JsonValue::CreateStringValue(password));
            newUser.Insert(L"role", JsonValue::CreateStringValue(role));
            newUser.Insert(L"status", JsonValue::CreateStringValue(L"active"));
            newUser.Insert(L"created_by", JsonValue::CreateStringValue(createdBy));

            Uri uri(m_projectUrl + L"/rest/v1/users");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Headers().Insert(L"Content-Type", L"application/json");
            request.Content(HttpStringContent(newUser.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    dispatcher.TryEnqueue([=]()
                    {
                        if (response.StatusCode() == HttpStatusCode::Created || response.StatusCode() == HttpStatusCode::Ok)
                        {
                            if (OnUserCreated)
                                OnUserCreated(L"User created successfully");
                        }
                        else
                        {
                            if (OnUserCreationFailed)
                                OnUserCreationFailed(L"Failed to create user");
                        }
                    });
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([=]()
                    {
                        if (OnUserCreationFailed)
                            OnUserCreationFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnUserCreationFailed)
                OnUserCreationFailed(L"Connection error");
        }
    }

    void SupabaseClient::ResetPassword(hstring const &userId, hstring const &newPassword)
    {
        try
        {
            if (m_currentUserRole != L"Admin")
            {
                auto dispatcher = DispatcherQueue::GetForCurrentThread();
                dispatcher.TryEnqueue([this]()
                                      {
                    if (OnUserActionFailed)
                        OnUserActionFailed(L"Permission denied: Only administrators can reset passwords"); });
                return;
            }

            if (newPassword.size() > 72)
            {
                auto dispatcher = DispatcherQueue::GetForCurrentThread();
                dispatcher.TryEnqueue([this]()
                                      {
                    if (OnUserActionFailed)
                        OnUserActionFailed(L"Password must not exceed 72 bytes"); });
                return;
            }

            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            JsonObject updateData;
            updateData.Insert(L"password_hash", JsonValue::CreateStringValue(newPassword));

            Uri uri(m_projectUrl + L"/rest/v1/users?id=eq." + userId);
            HttpRequestMessage request(HttpMethod::Patch(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Headers().Insert(L"Content-Type", L"application/json");
            request.Content(HttpStringContent(updateData.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    dispatcher.TryEnqueue([=]()
                    {
                        if (response.StatusCode() == HttpStatusCode::NoContent || response.StatusCode() == HttpStatusCode::Ok)
                        {
                            if (OnUserActionSuccess)
                                OnUserActionSuccess(L"Password reset successfully");
                        }
                        else
                        {
                            if (OnUserActionFailed)
                                OnUserActionFailed(L"Failed to reset password");
                        }
                    });
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([=]()
                    {
                        if (OnUserActionFailed)
                            OnUserActionFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnUserActionFailed)
                OnUserActionFailed(L"Connection error");
        }
    }

    void SupabaseClient::ToggleUserStatus(hstring const &userId, hstring const &newStatus)
    {
        try
        {
            if (m_currentUserRole != L"Admin")
            {
                auto dispatcher = DispatcherQueue::GetForCurrentThread();
                dispatcher.TryEnqueue([this]()
                                      {
                    if (OnUserActionFailed)
                        OnUserActionFailed(L"Permission denied: Only administrators can change user status"); });
                return;
            }

            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            JsonObject updateData;
            updateData.Insert(L"status", JsonValue::CreateStringValue(newStatus));

            Uri uri(m_projectUrl + L"/rest/v1/users?id=eq." + userId);
            HttpRequestMessage request(HttpMethod::Patch(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Headers().Insert(L"Content-Type", L"application/json");
            request.Content(HttpStringContent(updateData.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    dispatcher.TryEnqueue([=]()
                    {
                        if (response.StatusCode() == HttpStatusCode::NoContent || response.StatusCode() == HttpStatusCode::Ok)
                        {
                            if (OnUserActionSuccess)
                                OnUserActionSuccess(L"User status updated");
                        }
                        else
                        {
                            if (OnUserActionFailed)
                                OnUserActionFailed(L"Failed to update user status");
                        }
                    });
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([=]()
                    {
                        if (OnUserActionFailed)
                            OnUserActionFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnUserActionFailed)
                OnUserActionFailed(L"Connection error");
        }
    }

    void SupabaseClient::GetAllUsers()
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            Uri uri(m_projectUrl + L"/rest/v1/users?select=id,username,role,status");
            HttpRequestMessage request(HttpMethod::Get(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([=]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    if (OnUsersFetched)
                                        OnUsersFetched(content);
                                }
                                catch (...)
                                {
                                    if (OnUserActionFailed)
                                        OnUserActionFailed(L"Parse error");
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([=]()
                        {
                            if (OnUserActionFailed)
                                OnUserActionFailed(L"Failed to fetch users");
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([=]()
                    {
                        if (OnUserActionFailed)
                            OnUserActionFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnUserActionFailed)
                OnUserActionFailed(L"Connection error");
        }
    }

    void SupabaseClient::GetQuizzes(hstring const &createdBy)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            Uri uri(m_projectUrl + L"/rest/v1/quizzes?select=id,title,time_limit_minutes,total_points,created_by&created_by=eq." + createdBy);
            HttpRequestMessage request(HttpMethod::Get(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([=]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    if (OnQuizzesFetched)
                                        OnQuizzesFetched(content);
                                }
                                catch (...)
                                {
                                    if (OnQuizCreationFailed)
                                        OnQuizCreationFailed(L"Parse error");
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([=]()
                        {
                            if (OnQuizCreationFailed)
                                OnQuizCreationFailed(L"Failed to fetch quizzes");
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([=]()
                    {
                        if (OnQuizCreationFailed)
                            OnQuizCreationFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizCreationFailed)
                OnQuizCreationFailed(L"Connection error");
        }
    }

    void SupabaseClient::GetQuestions(hstring const &createdBy)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            Uri uri(m_projectUrl + L"/rest/v1/questions?select=id,question_text,difficulty_level,created_by,topic&created_by=eq." + createdBy);
            HttpRequestMessage request(HttpMethod::Get(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([=]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    if (OnQuestionsFetched)
                                        OnQuestionsFetched(content);
                                }
                                catch (...)
                                {
                                    if (OnQuizCreationFailed)
                                        OnQuizCreationFailed(L"Parse error");
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([=]()
                        {
                            if (OnQuizCreationFailed)
                                OnQuizCreationFailed(L"Failed to fetch questions");
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([=]()
                    {
                        if (OnQuizCreationFailed)
                            OnQuizCreationFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizCreationFailed)
                OnQuizCreationFailed(L"Connection error");
        }
    }

    void SupabaseClient::CreateQuiz(hstring const &quizId, hstring const &title, int timeLimit, int totalPoints, hstring const &createdBy)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            JsonObject quizData;
            quizData.Insert(L"id", JsonValue::CreateStringValue(quizId));
            quizData.Insert(L"title", JsonValue::CreateStringValue(title));
            quizData.Insert(L"time_limit_minutes", JsonValue::CreateNumberValue(timeLimit));
            quizData.Insert(L"total_points", JsonValue::CreateNumberValue(totalPoints));
            quizData.Insert(L"created_by", JsonValue::CreateStringValue(createdBy));
            quizData.Insert(L"shuffle_questions", JsonValue::CreateBooleanValue(false));
            quizData.Insert(L"shuffle_answers", JsonValue::CreateBooleanValue(false));

            Uri uri(m_projectUrl + L"/rest/v1/quizzes");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Headers().Insert(L"Content-Type", L"application/json");
            request.Headers().Insert(L"Prefer", L"return=representation");
            request.Content(HttpStringContent(quizData.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    dispatcher.TryEnqueue([this, response]()
                    {
                        if (response.StatusCode() == HttpStatusCode::Created || response.StatusCode() == HttpStatusCode::Ok)
                        {
                            if (OnQuizCreated)
                                OnQuizCreated(L"Quiz created successfully");
                        }
                        else
                        {
                            if (OnQuizCreationFailed)
                                OnQuizCreationFailed(L"Failed to create quiz");
                        }
                    });
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnQuizCreationFailed)
                            OnQuizCreationFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizCreationFailed)
                OnQuizCreationFailed(L"Connection error");
        }
    }

    void SupabaseClient::AddQuestionsToQuiz(hstring const &quizId, hstring const &questionId, int points)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            JsonObject questionData;
            questionData.Insert(L"quiz_id", JsonValue::CreateStringValue(quizId));
            questionData.Insert(L"question_id", JsonValue::CreateStringValue(questionId));
            questionData.Insert(L"points", JsonValue::CreateNumberValue(points));

            Uri uri(m_projectUrl + L"/rest/v1/quiz_questions");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Headers().Insert(L"Content-Type", L"application/json");
            request.Content(HttpStringContent(questionData.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    dispatcher.TryEnqueue([this, response]()
                    {
                        if (response.StatusCode() == HttpStatusCode::Created || response.StatusCode() == HttpStatusCode::Ok)
                        {
                            if (OnQuizCreated)
                                OnQuizCreated(L"Question added to quiz");
                        }
                        else
                        {
                            if (OnQuizCreationFailed)
                                OnQuizCreationFailed(L"Failed to add question");
                        }
                    });
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnQuizCreationFailed)
                            OnQuizCreationFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizCreationFailed)
                OnQuizCreationFailed(L"Connection error");
        }
    }

    void SupabaseClient::CreateQuestion(hstring const &questionId, hstring const &questionText, hstring const &optionA, hstring const &optionB, hstring const &optionC, hstring const &optionD, hstring const &correctOption, hstring const &difficulty, hstring const &createdBy)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            JsonObject questionData;
            questionData.Insert(L"id", JsonValue::CreateStringValue(questionId));
            questionData.Insert(L"question_text", JsonValue::CreateStringValue(questionText));
            questionData.Insert(L"option_a", JsonValue::CreateStringValue(optionA));
            questionData.Insert(L"option_b", JsonValue::CreateStringValue(optionB));
            questionData.Insert(L"option_c", JsonValue::CreateStringValue(optionC));
            questionData.Insert(L"option_d", JsonValue::CreateStringValue(optionD));
            questionData.Insert(L"correct_option", JsonValue::CreateStringValue(correctOption));
            questionData.Insert(L"difficulty_level", JsonValue::CreateStringValue(difficulty));
            questionData.Insert(L"created_by", JsonValue::CreateStringValue(createdBy));

            Uri uri(m_projectUrl + L"/rest/v1/questions");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Headers().Insert(L"Content-Type", L"application/json");
            request.Content(HttpStringContent(questionData.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    dispatcher.TryEnqueue([this, response]()
                    {
                        if (response.StatusCode() == HttpStatusCode::Created || response.StatusCode() == HttpStatusCode::Ok)
                        {
                            if (OnQuizCreated)
                                OnQuizCreated(L"Question created successfully");
                        }
                        else
                        {
                            if (OnQuizCreationFailed)
                                OnQuizCreationFailed(L"Failed to create question");
                        }
                    });
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnQuizCreationFailed)
                            OnQuizCreationFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizCreationFailed)
                OnQuizCreationFailed(L"Connection error");
        }
    }

    void SupabaseClient::GetQuestionsByTeacher(hstring const &createdBy)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            Uri uri(m_projectUrl + L"/rest/v1/questions?select=id,question_text,option_a,option_b,option_c,option_d,correct_option,difficulty_level,created_by&created_by=eq." + createdBy);
            HttpRequestMessage request(HttpMethod::Get(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([=]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    if (OnQuestionsFetched)
                                        OnQuestionsFetched(content);
                                }
                                catch (...)
                                {
                                    if (OnQuizCreationFailed)
                                        OnQuizCreationFailed(L"Parse error");
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([=]()
                        {
                            if (OnQuizCreationFailed)
                                OnQuizCreationFailed(L"Failed to fetch questions");
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([=]()
                    {
                        if (OnQuizCreationFailed)
                            OnQuizCreationFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizCreationFailed)
                OnQuizCreationFailed(L"Connection error");
        }
    }

    void SupabaseClient::DeleteQuestion(hstring const &questionId)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();
            Uri uri(m_projectUrl + L"/rest/v1/questions?id=eq." + questionId);
            HttpRequestMessage request(HttpMethod::Delete(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    dispatcher.TryEnqueue([this, response]()
                    {
                        if (response.StatusCode() == HttpStatusCode::NoContent || response.StatusCode() == HttpStatusCode::Ok)
                        {
                            if (OnQuizCreated)
                                OnQuizCreated(L"Question deleted successfully");
                        }
                        else
                        {
                            if (OnQuizCreationFailed)
                                OnQuizCreationFailed(L"Failed to delete question");
                        }
                    });
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnQuizCreationFailed)
                            OnQuizCreationFailed(L"Request error");
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizCreationFailed)
                OnQuizCreationFailed(L"Connection error");
        }
    }

    // =====================================================
    // UC02: Question Bank Management - Create with Validation
    // =====================================================
    void SupabaseClient::CreateQuestionValidated(
        hstring const &id,
        hstring const &teacherId,
        hstring const &text,
        hstring const &optA, hstring const &optB, hstring const &optC, hstring const &optD,
        hstring const &correctOpt,
        hstring const &difficulty,
        hstring const &topic)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            // Build JSON parameters matching RPC signature
            JsonObject params;
            params.Insert(L"p_id", JsonValue::CreateStringValue(id));
            params.Insert(L"p_created_by", JsonValue::CreateStringValue(teacherId));
            params.Insert(L"p_question_text", JsonValue::CreateStringValue(text));
            params.Insert(L"p_option_a", JsonValue::CreateStringValue(optA));
            params.Insert(L"p_option_b", JsonValue::CreateStringValue(optB));
            params.Insert(L"p_option_c", JsonValue::CreateStringValue(optC));
            params.Insert(L"p_option_d", JsonValue::CreateStringValue(optD));
            params.Insert(L"p_correct_option", JsonValue::CreateStringValue(correctOpt));
            params.Insert(L"p_difficulty_level", JsonValue::CreateStringValue(difficulty));
            params.Insert(L"p_topic", JsonValue::CreateStringValue(topic));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/create_question_validated");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                if (asyncOp.Status() == AsyncStatus::Completed)
                {
                    try
                    {
                        auto response = asyncOp.GetResults();
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    auto resultObj = JsonObject::Parse(content);
                                    auto status = resultObj.GetNamedString(L"status", L"error");
                                    auto message = resultObj.GetNamedString(L"message", L"Unknown error");

                                    if (OnQuestionValidatedCreated)
                                    {
                                        OnQuestionValidatedCreated(status == L"success", message);
                                    }
                                }
                                catch (...)
                                {
                                    if (OnQuestionValidatedCreated)
                                    {
                                        OnQuestionValidatedCreated(false, L"Failed to parse response");
                                    }
                                }
                            });
                        });
                    }
                    catch (...)
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnQuestionValidatedCreated)
                            {
                                OnQuestionValidatedCreated(false, L"Request failed");
                            }
                        });
                    }
                }
                else
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnQuestionValidatedCreated)
                        {
                            OnQuestionValidatedCreated(false, L"Network error");
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnQuestionValidatedCreated)
            {
                OnQuestionValidatedCreated(false, L"Connection error");
            }
        }
    }

    // =====================================================
    // UC02: Question Bank Management - Safe Delete
    // =====================================================
    void SupabaseClient::DeleteQuestionSafe(hstring const &questionId)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            JsonObject params;
            params.Insert(L"question_id_input", JsonValue::CreateStringValue(questionId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/delete_question_safe");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                if (asyncOp.Status() == AsyncStatus::Completed)
                {
                    try
                    {
                        auto response = asyncOp.GetResults();
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    auto resultObj = JsonObject::Parse(content);
                                    auto status = resultObj.GetNamedString(L"status", L"error");
                                    auto message = resultObj.GetNamedString(L"message", L"Unknown error");
                                    int quizCount = static_cast<int>(resultObj.GetNamedNumber(L"quiz_count", 0));

                                    if (OnQuestionDeleteResult)
                                    {
                                        OnQuestionDeleteResult(status, message, quizCount);
                                    }
                                }
                                catch (...)
                                {
                                    if (OnQuestionDeleteResult)
                                    {
                                        OnQuestionDeleteResult(L"error", L"Failed to parse response", 0);
                                    }
                                }
                            });
                        });
                    }
                    catch (...)
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnQuestionDeleteResult)
                            {
                                OnQuestionDeleteResult(L"error", L"Request failed", 0);
                            }
                        });
                    }
                }
                else
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnQuestionDeleteResult)
                        {
                            OnQuestionDeleteResult(L"error", L"Network error", 0);
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnQuestionDeleteResult)
            {
                OnQuestionDeleteResult(L"error", L"Connection error", 0);
            }
        }
    }

    // =====================================================
    // UC08: Quiz Management - Teacher Delete
    // =====================================================
    void SupabaseClient::DeleteQuizAsTeacher(hstring const &quizId, hstring const &teacherId)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            JsonObject params;
            params.Insert(L"quiz_id_input", JsonValue::CreateStringValue(quizId));
            params.Insert(L"teacher_id", JsonValue::CreateStringValue(teacherId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/delete_quiz_teacher");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                if (asyncOp.Status() == AsyncStatus::Completed)
                {
                    try
                    {
                        auto response = asyncOp.GetResults();
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    auto resultObj = JsonObject::Parse(content);
                                    auto status = resultObj.GetNamedString(L"status", L"error");
                                    auto message = resultObj.GetNamedString(L"message", L"Unknown error");
                                    int attemptCount = static_cast<int>(resultObj.GetNamedNumber(L"attempt_count", 0));

                                    bool success = (status == L"success");

                                    if (OnQuizDeleteResult)
                                    {
                                        OnQuizDeleteResult(success, message, attemptCount);
                                    }
                                }
                                catch (...)
                                {
                                    if (OnQuizDeleteResult)
                                    {
                                        OnQuizDeleteResult(false, L"Failed to parse response", 0);
                                    }
                                }
                            });
                        });
                    }
                    catch (...)
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnQuizDeleteResult)
                            {
                                OnQuizDeleteResult(false, L"Request failed", 0);
                            }
                        });
                    }
                }
                else
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnQuizDeleteResult)
                        {
                            OnQuizDeleteResult(false, L"Network error", 0);
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizDeleteResult)
            {
                OnQuizDeleteResult(false, L"Connection error", 0);
            }
        }
    }

    // =====================================================
    // UC08: Quiz Management - Admin Purge
    // =====================================================
    void SupabaseClient::PurgeQuizAsAdmin(hstring const &quizId, hstring const &adminId)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            JsonObject params;
            params.Insert(L"quiz_id_input", JsonValue::CreateStringValue(quizId));
            params.Insert(L"admin_id", JsonValue::CreateStringValue(adminId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/purge_quiz_admin");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                if (asyncOp.Status() == AsyncStatus::Completed)
                {
                    try
                    {
                        auto response = asyncOp.GetResults();
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    auto resultObj = JsonObject::Parse(content);
                                    auto status = resultObj.GetNamedString(L"status", L"error");
                                    auto message = resultObj.GetNamedString(L"message", L"Unknown error");
                                    int attemptsDeleted = static_cast<int>(resultObj.GetNamedNumber(L"attempts_deleted", 0));

                                    bool success = (status == L"success");

                                    if (OnQuizPurgeResult)
                                    {
                                        OnQuizPurgeResult(success, attemptsDeleted, message);
                                    }
                                }
                                catch (...)
                                {
                                    if (OnQuizPurgeResult)
                                    {
                                        OnQuizPurgeResult(false, 0, L"Failed to parse response");
                                    }
                                }
                            });
                        });
                    }
                    catch (...)
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnQuizPurgeResult)
                            {
                                OnQuizPurgeResult(false, 0, L"Request failed");
                            }
                        });
                    }
                }
                else
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnQuizPurgeResult)
                        {
                            OnQuizPurgeResult(false, 0, L"Network error");
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizPurgeResult)
            {
                OnQuizPurgeResult(false, 0, L"Connection error");
            }
        }
    }

    void SupabaseClient::GetQuizQuestions(hstring const &quizId)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            JsonObject params;
            params.Insert(L"input_quiz_id", JsonValue::CreateStringValue(quizId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/get_quiz_questions");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    auto questionsArray = JsonArray::Parse(content);

                                    std::vector<QuestionData> questions;
                                    for (uint32_t i = 0; i < questionsArray.Size(); ++i)
                                    {
                                        auto questionObj = questionsArray.GetObjectAt(i);
                                        QuestionData q;
                                        q.quiz_question_id = questionObj.GetNamedString(L"quiz_question_id");
                                        q.question_id = questionObj.GetNamedString(L"question_id");
                                        q.question_text = questionObj.GetNamedString(L"question_text");
                                        q.option_a = questionObj.GetNamedString(L"option_a");
                                        q.option_b = questionObj.GetNamedString(L"option_b");
                                        q.option_c = questionObj.GetNamedString(L"option_c");
                                        q.option_d = questionObj.GetNamedString(L"option_d");
                                        q.difficulty_level = questionObj.GetNamedString(L"difficulty_level");
                                        q.points = static_cast<int>(questionObj.GetNamedNumber(L"points"));
                                        q.order_num = static_cast<int>(questionObj.GetNamedNumber(L"order_num"));

                                        questions.push_back(q);
                                    }

                                    if (OnQuizQuestionsLoaded)
                                    {
                                        OnQuizQuestionsLoaded(true, questions);
                                    }
                                }
                                catch (...)
                                {
                                    if (OnQuizQuestionsLoaded)
                                    {
                                        OnQuizQuestionsLoaded(false, std::vector<QuestionData>());
                                    }
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnQuizQuestionsLoaded)
                            {
                                OnQuizQuestionsLoaded(false, std::vector<QuestionData>());
                            }
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnQuizQuestionsLoaded)
                        {
                            OnQuizQuestionsLoaded(false, std::vector<QuestionData>());
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizQuestionsLoaded)
            {
                OnQuizQuestionsLoaded(false, std::vector<QuestionData>());
            }
        }
    }

    void SupabaseClient::SubmitQuizAttempt(
        hstring const &studentId,
        hstring const &quizId,
        hstring const &answersJson,
        int timeSpentSeconds)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            // Parse answersJson and convert to JSONB
            auto answersArray = JsonArray::Parse(answersJson);

            JsonObject params;
            params.Insert(L"input_student_id", JsonValue::CreateStringValue(studentId));
            params.Insert(L"input_quiz_id", JsonValue::CreateStringValue(quizId));
            params.Insert(L"input_answers", answersArray);
            params.Insert(L"input_time_spent_seconds", JsonValue::CreateNumberValue(static_cast<double>(timeSpentSeconds)));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/submit_quiz_attempt");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    auto resultArray = JsonArray::Parse(content);

                                    if (resultArray.Size() > 0)
                                    {
                                        auto resultObj = resultArray.GetObjectAt(0);
                                        AttemptResult result;
                                        result.success = resultObj.GetNamedBoolean(L"success", false);
                                        result.attempt_id = resultObj.GetNamedString(L"attempt_id", L"");
                                        result.score = static_cast<int>(resultObj.GetNamedNumber(L"score", 0.0));
                                        result.total_points = static_cast<int>(resultObj.GetNamedNumber(L"total_points", 0.0));
                                        result.correct_count = static_cast<int>(resultObj.GetNamedNumber(L"correct_count", 0.0));
                                        result.incorrect_count = static_cast<int>(resultObj.GetNamedNumber(L"incorrect_count", 0.0));
                                        result.message = resultObj.GetNamedString(L"message", L"");

                                        if (OnAttemptSubmitted)
                                        {
                                            OnAttemptSubmitted(result);
                                        }
                                    }
                                }
                                catch (...)
                                {
                                    if (OnAttemptSubmitted)
                                    {
                                        AttemptResult result;
                                        result.success = false;
                                        result.message = L"Failed to parse response";
                                        OnAttemptSubmitted(result);
                                    }
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnAttemptSubmitted)
                            {
                                AttemptResult result;
                                result.success = false;
                                result.message = L"HTTP error";
                                OnAttemptSubmitted(result);
                            }
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnAttemptSubmitted)
                        {
                            AttemptResult result;
                            result.success = false;
                            result.message = L"Request failed";
                            OnAttemptSubmitted(result);
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnAttemptSubmitted)
            {
                AttemptResult result;
                result.success = false;
                result.message = L"Connection error";
                OnAttemptSubmitted(result);
            }
        }
    }

    void SupabaseClient::GetStudentQuizzes(hstring const &studentId)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            JsonObject params;
            params.Insert(L"input_student_id", JsonValue::CreateStringValue(studentId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/get_student_quizzes");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    auto quizzesArray = JsonArray::Parse(content);

                                    std::vector<QuizData> quizzes;
                                    for (uint32_t i = 0; i < quizzesArray.Size(); ++i)
                                    {
                                        auto quizObj = quizzesArray.GetObjectAt(i);
                                        QuizData q;
                                        q.quiz_id = quizObj.GetNamedString(L"quiz_id");
                                        q.quiz_title = quizObj.GetNamedString(L"quiz_title");
                                        q.time_limit_minutes = static_cast<int>(quizObj.GetNamedNumber(L"time_limit_minutes"));
                                        q.total_points = static_cast<int>(quizObj.GetNamedNumber(L"total_points"));
                                        q.max_attempts = quizObj.GetNamedString(L"max_attempts");
                                        q.attempts_used = static_cast<int>(quizObj.GetNamedNumber(L"attempts_used"));
                                        q.result_visibility = quizObj.GetNamedString(L"result_visibility");

                                        quizzes.push_back(q);
                                    }

                                    if (OnStudentQuizzesLoaded)
                                    {
                                        OnStudentQuizzesLoaded(true, quizzes);
                                    }
                                }
                                catch (...)
                                {
                                    if (OnStudentQuizzesLoaded)
                                    {
                                        OnStudentQuizzesLoaded(false, std::vector<QuizData>());
                                    }
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnStudentQuizzesLoaded)
                            {
                                OnStudentQuizzesLoaded(false, std::vector<QuizData>());
                            }
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnStudentQuizzesLoaded)
                        {
                            OnStudentQuizzesLoaded(false, std::vector<QuizData>());
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnStudentQuizzesLoaded)
            {
                OnStudentQuizzesLoaded(false, std::vector<QuizData>());
            }
        }
    }

    void SupabaseClient::GetAttemptResults(hstring const &studentId, hstring const &quizId)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            JsonObject params;
            params.Insert(L"input_student_id", JsonValue::CreateStringValue(studentId));
            params.Insert(L"input_quiz_id", JsonValue::CreateStringValue(quizId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/get_attempt_results");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    auto attemptsArray = JsonArray::Parse(content);

                                    std::vector<AttemptData> attempts;
                                    for (uint32_t i = 0; i < attemptsArray.Size(); ++i)
                                    {
                                        auto attemptObj = attemptsArray.GetObjectAt(i);
                                        AttemptData a;
                                        a.attempt_id = attemptObj.GetNamedString(L"attempt_id");
                                        a.attempt_number = static_cast<int>(attemptObj.GetNamedNumber(L"attempt_number"));
                                        a.score = static_cast<int>(attemptObj.GetNamedNumber(L"score"));
                                        a.total_points = static_cast<int>(attemptObj.GetNamedNumber(L"total_points"));
                                        a.correct_count = static_cast<int>(attemptObj.GetNamedNumber(L"correct_count"));
                                        a.incorrect_count = static_cast<int>(attemptObj.GetNamedNumber(L"incorrect_count"));

                                        attempts.push_back(a);
                                    }

                                    if (OnAttemptResultsLoaded)
                                    {
                                        OnAttemptResultsLoaded(true, attempts);
                                    }
                                }
                                catch (...)
                                {
                                    if (OnAttemptResultsLoaded)
                                    {
                                        OnAttemptResultsLoaded(false, std::vector<AttemptData>());
                                    }
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnAttemptResultsLoaded)
                            {
                                OnAttemptResultsLoaded(false, std::vector<AttemptData>());
                            }
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnAttemptResultsLoaded)
                        {
                            OnAttemptResultsLoaded(false, std::vector<AttemptData>());
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnAttemptResultsLoaded)
            {
                OnAttemptResultsLoaded(false, std::vector<AttemptData>());
            }
        }
    }

    void SupabaseClient::GetAttemptDetailsWithAnswers(hstring const &attemptId)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            JsonObject params;
            params.Insert(L"input_attempt_id", JsonValue::CreateStringValue(attemptId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/get_attempt_details_with_answers");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    auto answersArray = JsonArray::Parse(content);

                                    std::vector<AnswerDetail> answers;
                                    for (uint32_t i = 0; i < answersArray.Size(); ++i)
                                    {
                                        auto answerObj = answersArray.GetObjectAt(i);
                                        AnswerDetail a;
                                        a.question_id = answerObj.GetNamedString(L"question_id");
                                        a.question_text = answerObj.GetNamedString(L"question_text");
                                        a.selected_option = answerObj.GetNamedString(L"selected_option", L"");
                                        a.correct_option = answerObj.GetNamedString(L"correct_option");
                                        a.is_correct = answerObj.GetNamedBoolean(L"is_correct", false);
                                        a.points_earned = static_cast<int>(answerObj.GetNamedNumber(L"points_earned", 0.0));
                                        a.total_possible_points = static_cast<int>(answerObj.GetNamedNumber(L"total_possible_points", 0.0));

                                        answers.push_back(a);
                                    }

                                    if (OnAttemptDetailsLoaded)
                                    {
                                        OnAttemptDetailsLoaded(true, answers);
                                    }
                                }
                                catch (...)
                                {
                                    if (OnAttemptDetailsLoaded)
                                    {
                                        OnAttemptDetailsLoaded(false, std::vector<AnswerDetail>());
                                    }
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnAttemptDetailsLoaded)
                            {
                                OnAttemptDetailsLoaded(false, std::vector<AnswerDetail>());
                            }
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnAttemptDetailsLoaded)
                        {
                            OnAttemptDetailsLoaded(false, std::vector<AnswerDetail>());
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnAttemptDetailsLoaded)
            {
                OnAttemptDetailsLoaded(false, std::vector<AnswerDetail>());
            }
        }
    }

    void SupabaseClient::GetQuizAttemptsReport(hstring const &quizId)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            JsonObject params;
            params.Insert(L"input_quiz_id", JsonValue::CreateStringValue(quizId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/get_quiz_attempts_report");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto content = readOp.GetResults();
                                    auto reportsArray = JsonArray::Parse(content);

                                    std::vector<AttemptReportRow> reports;
                                    for (uint32_t i = 0; i < reportsArray.Size(); ++i)
                                    {
                                        auto reportObj = reportsArray.GetObjectAt(i);
                                        AttemptReportRow r;
                                        r.student_id = reportObj.GetNamedString(L"student_id");
                                        r.username = reportObj.GetNamedString(L"username");
                                        r.attempt_number = static_cast<int>(reportObj.GetNamedNumber(L"attempt_number"));
                                        r.score = static_cast<int>(reportObj.GetNamedNumber(L"score"));
                                        r.total_points = static_cast<int>(reportObj.GetNamedNumber(L"total_points"));
                                        r.correct_count = static_cast<int>(reportObj.GetNamedNumber(L"correct_count"));
                                        r.incorrect_count = static_cast<int>(reportObj.GetNamedNumber(L"incorrect_count"));
                                        r.time_spent_seconds = static_cast<int>(reportObj.GetNamedNumber(L"time_spent_seconds", 0.0));

                                        reports.push_back(r);
                                    }

                                    if (OnQuizReportLoaded)
                                    {
                                        OnQuizReportLoaded(true, reports);
                                    }
                                }
                                catch (...)
                                {
                                    if (OnQuizReportLoaded)
                                    {
                                        OnQuizReportLoaded(false, std::vector<AttemptReportRow>());
                                    }
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnQuizReportLoaded)
                            {
                                OnQuizReportLoaded(false, std::vector<AttemptReportRow>());
                            }
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnQuizReportLoaded)
                        {
                            OnQuizReportLoaded(false, std::vector<AttemptReportRow>());
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnQuizReportLoaded)
            {
                OnQuizReportLoaded(false, std::vector<AttemptReportRow>());
            }
        }
    }

    void SupabaseClient::GetQuizReportCsv(hstring const &quizId)
    {
        try
        {
            auto dispatcher = DispatcherQueue::GetForCurrentThread();

            JsonObject params;
            params.Insert(L"input_quiz_id", JsonValue::CreateStringValue(quizId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/get_quiz_attempts_report");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Headers().Insert(L"Accept", L"text/csv");
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            m_httpClient.SendRequestAsync(request).Completed([this, dispatcher](auto const &asyncOp, auto)
                                                             {
                try
                {
                    auto response = asyncOp.GetResults();
                    if (response.StatusCode() == HttpStatusCode::Ok)
                    {
                        response.Content().ReadAsStringAsync().Completed([this, dispatcher](auto const &readOp, auto)
                        {
                            dispatcher.TryEnqueue([this, readOp]()
                            {
                                try
                                {
                                    auto csvContent = readOp.GetResults();
                                    if (OnCsvReportLoaded)
                                    {
                                        OnCsvReportLoaded(true, csvContent);
                                    }
                                }
                                catch (...)
                                {
                                    if (OnCsvReportLoaded)
                                    {
                                        OnCsvReportLoaded(false, L"");
                                    }
                                }
                            });
                        });
                    }
                    else
                    {
                        dispatcher.TryEnqueue([this]()
                        {
                            if (OnCsvReportLoaded)
                            {
                                OnCsvReportLoaded(false, L"");
                            }
                        });
                    }
                }
                catch (...)
                {
                    dispatcher.TryEnqueue([this]()
                    {
                        if (OnCsvReportLoaded)
                        {
                            OnCsvReportLoaded(false, L"");
                        }
                    });
                } });
        }
        catch (...)
        {
            if (OnCsvReportLoaded)
            {
                OnCsvReportLoaded(false, L"");
            }
        }
    }
}
</code>

SupabaseClient.h:
<code>
#pragma once

#include <winrt/Windows.Foundation.h>
#include <winrt/Windows.Web.Http.h>
#include <winrt/Windows.Data.Json.h>
#include <functional>
#include <memory>

using namespace winrt;
using namespace Windows::Foundation;
using namespace Windows::Web::Http;
using namespace Windows::Data::Json;

namespace quiz_examination_system
{
    class SupabaseClient
    {
    public:
        SupabaseClient();

        void Login(hstring const &username, hstring const &password);
        void ChangePassword(hstring const &username, hstring const &currentPassword, hstring const &newPassword);
        void CreateUser(hstring const &username, hstring const &password, hstring const &role, hstring const &createdBy);
        void ResetPassword(hstring const &userId, hstring const &newPassword);
        void ToggleUserStatus(hstring const &userId, hstring const &newStatus);
        void GetAllUsers();
        void GetQuizzes(hstring const &createdBy);
        void GetQuestions(hstring const &createdBy);
        void CreateQuiz(hstring const &quizId, hstring const &title, int timeLimit, int totalPoints, hstring const &createdBy);
        void AddQuestionsToQuiz(hstring const &quizId, hstring const &questionId, int points);
        void CreateQuestion(hstring const &questionId, hstring const &questionText, hstring const &optionA, hstring const &optionB, hstring const &optionC, hstring const &optionD, hstring const &correctOption, hstring const &difficulty, hstring const &createdBy);
        void GetQuestionsByTeacher(hstring const &createdBy);
        void DeleteQuestion(hstring const &questionId);

        // --- Question Bank Management (UC02) ---
        void CreateQuestionValidated(
            hstring const &id,
            hstring const &teacherId,
            hstring const &text,
            hstring const &optA, hstring const &optB, hstring const &optC, hstring const &optD,
            hstring const &correctOpt,
            hstring const &difficulty,
            hstring const &topic);

        void DeleteQuestionSafe(hstring const &questionId);

        // --- Quiz Management (UC08) ---
        void DeleteQuizAsTeacher(hstring const &quizId, hstring const &teacherId);
        void PurgeQuizAsAdmin(hstring const &quizId, hstring const &adminId);

        bool IsConnected() const { return m_connected; }
        hstring GetLastError() const { return m_lastError; }

        std::function<void(hstring, hstring, hstring, hstring)> OnLoginSuccess;
        std::function<void(hstring)> OnLoginFailed;
        std::function<void(hstring)> OnPasswordChanged;
        std::function<void(hstring)> OnPasswordChangeFailed;
        std::function<void(hstring)> OnUserCreated;
        std::function<void(hstring)> OnUserCreationFailed;
        std::function<void(hstring)> OnUsersFetched;
        std::function<void(hstring)> OnUserActionSuccess;
        std::function<void(hstring)> OnUserActionFailed;
        std::function<void(hstring)> OnQuizzesFetched;
        std::function<void(hstring)> OnQuestionsFetched;
        std::function<void(hstring)> OnQuizCreated;
        std::function<void(hstring)> OnQuizCreationFailed;

        // --- UC02 Question Bank Callbacks ---
        std::function<void(bool, hstring)> OnQuestionValidatedCreated;
        std::function<void(hstring, hstring, int)> OnQuestionDeleteResult; // status, message, quiz_count

        // --- UC08 Quiz Management Callbacks ---
        std::function<void(bool, hstring, int)> OnQuizDeleteResult; // success, message, attempt_count
        std::function<void(bool, int, hstring)> OnQuizPurgeResult;  // success, attempts_deleted, message

        // --- UC04 Take Quiz & UC05 Grading ---
        void GetQuizQuestions(hstring const &quizId);
        void SubmitQuizAttempt(
            hstring const &studentId,
            hstring const &quizId,
            hstring const &answersJson,
            int timeSpentSeconds);
        void GetStudentQuizzes(hstring const &studentId);
        void GetAttemptResults(hstring const &studentId, hstring const &quizId);
        void GetAttemptDetailsWithAnswers(hstring const &attemptId);
        void GetQuizAttemptsReport(hstring const &quizId);
        void GetQuizReportCsv(hstring const &quizId);

        // Callbacks for UC04/UC05
        struct QuestionData
        {
            hstring quiz_question_id;
            hstring question_id;
            hstring question_text;
            hstring option_a;
            hstring option_b;
            hstring option_c;
            hstring option_d;
            hstring difficulty_level;
            int points;
            int order_num;
        };

        struct QuizData
        {
            hstring quiz_id;
            hstring quiz_title;
            int time_limit_minutes;
            int total_points;
            hstring max_attempts;
            int attempts_used;
            hstring result_visibility;
        };

        struct AttemptData
        {
            hstring attempt_id;
            int attempt_number;
            int score;
            int total_points;
            int correct_count;
            int incorrect_count;
        };

        struct AnswerDetail
        {
            hstring question_id;
            hstring question_text;
            hstring selected_option;
            hstring correct_option;
            bool is_correct;
            int points_earned;
            int total_possible_points;
        };

        struct AttemptReportRow
        {
            hstring student_id;
            hstring username;
            int attempt_number;
            int score;
            int total_points;
            int correct_count;
            int incorrect_count;
            int time_spent_seconds;
        };

        struct AttemptResult
        {
            bool success;
            hstring attempt_id;
            int score;
            int total_points;
            int correct_count;
            int incorrect_count;
            hstring message;
        };

        std::function<void(bool, std::vector<QuestionData>)> OnQuizQuestionsLoaded;  // success, questions
        std::function<void(bool, std::vector<QuizData>)> OnStudentQuizzesLoaded;     // success, quizzes
        std::function<void(bool, std::vector<AttemptData>)> OnAttemptResultsLoaded;  // success, attempts
        std::function<void(bool, std::vector<AnswerDetail>)> OnAttemptDetailsLoaded; // success, answer details
        std::function<void(bool, std::vector<AttemptReportRow>)> OnQuizReportLoaded; // success, report rows
        std::function<void(AttemptResult)> OnAttemptSubmitted;                       // result
        std::function<void(bool, hstring)> OnCsvReportLoaded;                        // success, csv_content

        void SetCurrentUserRole(hstring const &role) { m_currentUserRole = role; }

    private:
        HttpClient m_httpClient;
        hstring m_projectUrl{L"https://tuciofxdzzrzwzqsltps.supabase.co"};
        hstring m_anonKey{L"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1Y2lvZnhkenpyend6cXNsdHBzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg3NTY5ODAsImV4cCI6MjA4NDMzMjk4MH0.2b1FYJ1GxNm_Jwg6TkP0Lf7ZOuvkVctc_96EV_uzVnI"};
        bool m_connected{true};
        hstring m_lastError;
        hstring m_currentUserRole{L""};
    };
}

</code>

SupabaseClientAsync.cpp:
<code>
#include "pch.h"
#include "SupabaseClientAsync.h"
#include "BCryptPasswordHasher.h"
#include <winrt/Windows.Web.Http.Filters.h>

using namespace winrt;
using namespace Windows::Foundation;
using namespace Windows::Web::Http;
using namespace Windows::Web::Http::Filters;
using namespace Windows::Data::Json;

namespace quiz_examination_system
{
    SupabaseClientAsync::SupabaseClientAsync()
        : m_connected(true)
    {
        HttpBaseProtocolFilter filter;
        m_httpClient = HttpClient(filter);
    }

    IAsyncOperation<LoginResult> SupabaseClientAsync::LoginAsync(hstring const &username, hstring const &password)
    {
        LoginResult result;
        result.success = false;

        try
        {
            JsonObject statusParams;
            statusParams.Insert(L"input_username", JsonValue::CreateStringValue(username));
            Uri statusUri(m_projectUrl + L"/rest/v1/rpc/check_account_status");
            HttpRequestMessage statusReq(HttpMethod::Post(), statusUri);
            statusReq.Headers().Insert(L"apikey", m_anonKey);
            statusReq.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            statusReq.Content(HttpStringContent(statusParams.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            auto statusResponse = co_await m_httpClient.SendRequestAsync(statusReq);
            auto statusContent = co_await statusResponse.Content().ReadAsStringAsync();
            auto statusObj = JsonObject::Parse(statusContent);
            auto checkStatus = statusObj.GetNamedString(L"status", L"");

            if (checkStatus == L"user_not_found")
            {
                result.errorMessage = L"User not found";
                co_return result;
            }
            else if (checkStatus == L"locked")
            {
                auto minutesRemaining = static_cast<int>(statusObj.GetNamedNumber(L"minutes_remaining", 30));
                result.errorMessage = hstring(L"Account is locked. Try again in ") + to_hstring(minutesRemaining) + L" minutes.";
                co_return result;
            }
            else if (checkStatus == L"inactive")
            {
                result.errorMessage = L"Account is inactive";
                co_return result;
            }

            Uri uri(m_projectUrl + L"/rest/v1/users?select=id,username,password_hash,role&username=eq." + username);
            HttpRequestMessage request(HttpMethod::Get(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);

            auto response = co_await m_httpClient.SendRequestAsync(request);
            if (response.StatusCode() != HttpStatusCode::Ok)
            {
                result.errorMessage = L"Login failed";
                co_return result;
            }

            auto content = co_await response.Content().ReadAsStringAsync();
            JsonArray users = JsonArray::Parse(content);

            if (users.Size() > 0)
            {
                auto user = users.GetObjectAt(0);
                auto userId = user.GetNamedString(L"id");
                auto storedHash = user.GetNamedString(L"password_hash");
                auto role = user.GetNamedString(L"role", L"Student");

                if (BCryptPasswordHasher::VerifyPassword(password, storedHash))
                {
                    JsonObject resetParams;
                    resetParams.Insert(L"input_username", JsonValue::CreateStringValue(username));
                    Uri resetUri(m_projectUrl + L"/rest/v1/rpc/handle_login_success");
                    HttpRequestMessage resetReq(HttpMethod::Post(), resetUri);
                    resetReq.Headers().Insert(L"apikey", m_anonKey);
                    resetReq.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
                    resetReq.Content(HttpStringContent(resetParams.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

                    co_await m_httpClient.SendRequestAsync(resetReq);

                    result.success = true;
                    result.username = username;
                    result.role = role;
                    result.userId = userId;
                    result.displayRole = (role == L"Admin") ? L"Administrator" : (role == L"Teacher") ? L"Lecturer"
                                                                                                      : L"Student";
                }
                else
                {
                    JsonObject rpcParams;
                    rpcParams.Insert(L"input_username", JsonValue::CreateStringValue(username));
                    Uri rpcUri(m_projectUrl + L"/rest/v1/rpc/handle_login_failure");
                    HttpRequestMessage rpcReq(HttpMethod::Post(), rpcUri);
                    rpcReq.Headers().Insert(L"apikey", m_anonKey);
                    rpcReq.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
                    rpcReq.Content(HttpStringContent(rpcParams.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

                    co_await m_httpClient.SendRequestAsync(rpcReq);

                    result.errorMessage = L"Incorrect password";
                }
            }
            else
            {
                result.errorMessage = L"User not found";
            }
        }
        catch (hresult_error const &ex)
        {
            result.errorMessage = ex.message();
        }

        co_return result;
    }

    IAsyncOperation<bool> SupabaseClientAsync::ChangePasswordAsync(hstring const &username, hstring const &currentPassword, hstring const &newPassword)
    {
        try
        {
            Uri uri(m_projectUrl + L"/rest/v1/users?select=id,password_hash&username=eq." + username);
            HttpRequestMessage request(HttpMethod::Get(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);

            auto response = co_await m_httpClient.SendRequestAsync(request);
            if (response.StatusCode() != HttpStatusCode::Ok)
            {
                co_return false;
            }

            auto content = co_await response.Content().ReadAsStringAsync();
            JsonArray users = JsonArray::Parse(content);

            if (users.Size() == 0)
            {
                co_return false;
            }

            auto user = users.GetObjectAt(0);
            auto userId = user.GetNamedString(L"id");
            auto storedHash = user.GetNamedString(L"password_hash");

            if (!BCryptPasswordHasher::VerifyPassword(currentPassword, storedHash))
            {
                co_return false;
            }

            auto newHash = BCryptPasswordHasher::HashPassword(newPassword);
            JsonObject updateData;
            updateData.Insert(L"password_hash", JsonValue::CreateStringValue(newHash));

            Uri updateUri(m_projectUrl + L"/rest/v1/users?id=eq." + userId);
            HttpRequestMessage updateReq(HttpMethod::Patch(), updateUri);
            updateReq.Headers().Insert(L"apikey", m_anonKey);
            updateReq.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            updateReq.Headers().Insert(L"Prefer", L"return=minimal");
            updateReq.Content(HttpStringContent(updateData.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            auto updateResponse = co_await m_httpClient.SendRequestAsync(updateReq);
            co_return updateResponse.StatusCode() == HttpStatusCode::NoContent;
        }
        catch (...)
        {
            co_return false;
        }
    }

    IAsyncOperation<hstring> SupabaseClientAsync::GetQuestionsJsonAsync(hstring const &createdBy)
    {
        try
        {
            Uri uri(m_projectUrl + L"/rest/v1/questions?select=*&created_by=eq." + createdBy + L"&order=created_at.desc");
            HttpRequestMessage request(HttpMethod::Get(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);

            auto response = co_await m_httpClient.SendRequestAsync(request);
            if (response.StatusCode() == HttpStatusCode::Ok)
            {
                auto content = co_await response.Content().ReadAsStringAsync();
                co_return content;
            }
        }
        catch (...)
        {
        }
        co_return L"[]";
    }

    IAsyncOperation<QuestionCreateResult> SupabaseClientAsync::CreateQuestionValidatedAsync(
        hstring const &id, hstring const &teacherId, hstring const &text,
        hstring const &optA, hstring const &optB, hstring const &optC, hstring const &optD,
        hstring const &correctOpt, hstring const &difficulty, hstring const &topic)
    {
        QuestionCreateResult result;
        result.success = false;

        try
        {
            JsonObject questionData;
            questionData.Insert(L"id", JsonValue::CreateStringValue(id));
            questionData.Insert(L"created_by", JsonValue::CreateStringValue(teacherId));
            questionData.Insert(L"question_text", JsonValue::CreateStringValue(text));
            questionData.Insert(L"option_a", JsonValue::CreateStringValue(optA));
            questionData.Insert(L"option_b", JsonValue::CreateStringValue(optB));
            questionData.Insert(L"option_c", JsonValue::CreateStringValue(optC));
            questionData.Insert(L"option_d", JsonValue::CreateStringValue(optD));
            questionData.Insert(L"correct_option", JsonValue::CreateStringValue(correctOpt));
            questionData.Insert(L"difficulty_level", JsonValue::CreateStringValue(difficulty));
            questionData.Insert(L"topic", JsonValue::CreateStringValue(topic));

            Uri uri(m_projectUrl + L"/rest/v1/questions");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Headers().Insert(L"Prefer", L"return=minimal");
            request.Content(HttpStringContent(questionData.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            auto response = co_await m_httpClient.SendRequestAsync(request);

            if (response.StatusCode() == HttpStatusCode::Created)
            {
                result.success = true;
                result.message = L"Question created successfully";
            }
            else
            {
                result.message = L"Failed to create question";
            }
        }
        catch (hresult_error const &ex)
        {
            result.message = ex.message();
        }

        co_return result;
    }

    IAsyncOperation<bool> SupabaseClientAsync::DeleteQuestionSafeAsync(hstring const &questionId)
    {
        try
        {
            Uri uri(m_projectUrl + L"/rest/v1/questions?id=eq." + questionId);
            HttpRequestMessage request(HttpMethod::Delete(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Headers().Insert(L"Prefer", L"return=minimal");

            auto response = co_await m_httpClient.SendRequestAsync(request);
            co_return response.StatusCode() == HttpStatusCode::NoContent;
        }
        catch (...)
        {
            co_return false;
        }
    }

    IAsyncOperation<std::vector<QuestionData>> SupabaseClientAsync::GetQuizQuestionsAsync(hstring const &quizId)
    {
        std::vector<QuestionData> questions;

        try
        {
            JsonObject params;
            params.Insert(L"p_quiz_id", JsonValue::CreateStringValue(quizId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/get_quiz_questions_v2");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            auto response = co_await m_httpClient.SendRequestAsync(request);
            if (response.StatusCode() == HttpStatusCode::Ok)
            {
                auto content = co_await response.Content().ReadAsStringAsync();
                auto questionsArray = JsonArray::Parse(content);

                for (uint32_t i = 0; i < questionsArray.Size(); ++i)
                {
                    auto qObj = questionsArray.GetObjectAt(i);
                    QuestionData q;
                    q.quiz_question_id = qObj.GetNamedString(L"quiz_question_id", L"");
                    q.question_id = qObj.GetNamedString(L"question_id", L"");
                    q.question_text = qObj.GetNamedString(L"question_text", L"");
                    q.option_a = qObj.GetNamedString(L"option_a", L"");
                    q.option_b = qObj.GetNamedString(L"option_b", L"");
                    q.option_c = qObj.GetNamedString(L"option_c", L"");
                    q.option_d = qObj.GetNamedString(L"option_d", L"");
                    q.difficulty_level = qObj.GetNamedString(L"difficulty_level", L"");
                    q.points = static_cast<int>(qObj.GetNamedNumber(L"points", 1));
                    q.order_num = static_cast<int>(qObj.GetNamedNumber(L"order_num", 0));
                    questions.push_back(q);
                }
            }
        }
        catch (...)
        {
        }

        co_return questions;
    }

    IAsyncOperation<std::vector<QuizData>> SupabaseClientAsync::GetStudentQuizzesAsync(hstring const &studentId)
    {
        std::vector<QuizData> quizzes;

        try
        {
            JsonObject params;
            params.Insert(L"p_student_id", JsonValue::CreateStringValue(studentId));

            Uri uri(m_projectUrl + L"/rest/v1/rpc/get_student_quizzes_v2");
            HttpRequestMessage request(HttpMethod::Post(), uri);
            request.Headers().Insert(L"apikey", m_anonKey);
            request.Headers().Insert(L"Authorization", hstring(L"Bearer ") + m_anonKey);
            request.Content(HttpStringContent(params.Stringify(), Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));

            auto response = co_await m_httpClient.SendRequestAsync(request);
            if (response.StatusCode() == HttpStatusCode::Ok)
            {
                auto content = co_await response.Content().ReadAsStringAsync();
                auto quizzesArray = JsonArray::Parse(content);

                for (uint32_t i = 0; i < quizzesArray.Size(); ++i)
                {
                    auto qObj = quizzesArray.GetObjectAt(i);
                    QuizData q;
                    q.quiz_id = qObj.GetNamedString(L"quiz_id", L"");
                    q.quiz_title = qObj.GetNamedString(L"quiz_title", L"");
                    q.time_limit_minutes = static_cast<int>(qObj.GetNamedNumber(L"time_limit_minutes", 0));
                    q.total_points = static_cast<int>(qObj.GetNamedNumber(L"total_points", 0));
                    q.max_attempts = qObj.GetNamedString(L"max_attempts", L"unlimited");
                    q.attempts_used = static_cast<int>(qObj.GetNamedNumber(L"attempts_used", 0));
                    q.result_visibility = qObj.GetNamedString(L"result_visibility", L"immediate");
                    quizzes.push_back(q);
                }
            }
        }
        catch (...)
        {
        }

        co_return quizzes;
    }
}

</code>

SupabaseClientAsync.h:
<code>
#pragma once

#include <winrt/Windows.Foundation.h>
#include <winrt/Windows.Web.Http.h>
#include <winrt/Windows.Data.Json.h>

using namespace winrt;
using namespace Windows::Foundation;
using namespace Windows::Web::Http;
using namespace Windows::Data::Json;

namespace quiz_examination_system
{
    struct LoginResult
    {
        bool success;
        hstring username;
        hstring displayRole;
        hstring role;
        hstring userId;
        hstring errorMessage;
    };

    struct QuestionData
    {
        hstring quiz_question_id;
        hstring question_id;
        hstring question_text;
        hstring option_a;
        hstring option_b;
        hstring option_c;
        hstring option_d;
        hstring difficulty_level;
        int points;
        int order_num;
    };

    struct QuizData
    {
        hstring quiz_id;
        hstring quiz_title;
        int time_limit_minutes;
        int total_points;
        hstring max_attempts;
        int attempts_used;
        hstring result_visibility;
    };

    struct QuestionCreateResult
    {
        bool success;
        hstring message;
    };

    class SupabaseClientAsync
    {
    public:
        SupabaseClientAsync();

        IAsyncOperation<LoginResult> LoginAsync(hstring const &username, hstring const &password);

        IAsyncOperation<bool> ChangePasswordAsync(hstring const &username, hstring const &currentPassword, hstring const &newPassword);

        IAsyncOperation<hstring> GetQuestionsJsonAsync(hstring const &createdBy);

        IAsyncOperation<QuestionCreateResult> CreateQuestionValidatedAsync(
            hstring const &id,
            hstring const &teacherId,
            hstring const &text,
            hstring const &optA, hstring const &optB, hstring const &optC, hstring const &optD,
            hstring const &correctOpt,
            hstring const &difficulty,
            hstring const &topic);

        IAsyncOperation<bool> DeleteQuestionSafeAsync(hstring const &questionId);

        IAsyncOperation<std::vector<QuestionData>> GetQuizQuestionsAsync(hstring const &quizId);

        IAsyncOperation<std::vector<QuizData>> GetStudentQuizzesAsync(hstring const &studentId);

        bool IsConnected() const { return m_connected; }
        hstring GetLastError() const { return m_lastError; }

    private:
        HttpClient m_httpClient;
        bool m_connected;
        hstring m_lastError;

        hstring m_projectUrl{L"https://tuciofxdzzrzwzqsltps.supabase.co"};
        hstring m_anonKey{L"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1Y2lvZnhkenp6cnd6cXNsdHBzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzcyNjYyMzEsImV4cCI6MjA1Mjg0MjIzMX0.7XA0u31rlq7cCfUw5gjKX9pTt9x4X8Bh_AY6_LWmfuA"};
    };
}

</code>

SupabaseClientManager.cpp:
<code>
#include "pch.h"
#include "SupabaseClientManager.h"
#include <winrt/Windows.Storage.h>

using namespace winrt;
using namespace Windows::Storage;

namespace quiz_examination_system
{
    SupabaseClientManager &SupabaseClientManager::GetInstance()
    {
        static SupabaseClientManager instance;
        return instance;
    }

    SupabaseClientManager::SupabaseClientManager()
    {
        m_client = std::make_unique<SupabaseClient>();
        LoadSessionFromSettings();
    }

    SupabaseClient *SupabaseClientManager::GetClient()
    {
        return m_client.get();
    }

    void SupabaseClientManager::SaveSession(hstring const &userId, hstring const &username, hstring const &role)
    {
        m_userId = userId;
        m_username = username;
        m_role = role;

        auto localSettings = ApplicationData::Current().LocalSettings();
        localSettings.Values().Insert(L"userId", box_value(userId));
        localSettings.Values().Insert(L"username", box_value(username));
        localSettings.Values().Insert(L"role", box_value(role));
    }

    void SupabaseClientManager::ClearSession()
    {
        m_userId = L"";
        m_username = L"";
        m_role = L"";

        auto localSettings = ApplicationData::Current().LocalSettings();
        localSettings.Values().Remove(L"userId");
        localSettings.Values().Remove(L"username");
        localSettings.Values().Remove(L"role");
    }

    void SupabaseClientManager::LoadSessionFromSettings()
    {
        try
        {
            auto localSettings = ApplicationData::Current().LocalSettings();
            auto values = localSettings.Values();

            if (values.HasKey(L"userId"))
            {
                m_userId = unbox_value<hstring>(values.Lookup(L"userId"));
                m_username = unbox_value<hstring>(values.Lookup(L"username"));
                m_role = unbox_value<hstring>(values.Lookup(L"role"));
            }
        }
        catch (...)
        {
        }
    }

    bool SupabaseClientManager::HasActiveSession() const
    {
        return !m_userId.empty();
    }

    hstring SupabaseClientManager::GetUserId() const
    {
        return m_userId;
    }

    hstring SupabaseClientManager::GetUsername() const
    {
        return m_username;
    }

    hstring SupabaseClientManager::GetRole() const
    {
        return m_role;
    }
}

</code>

SupabaseClientManager.h:
<code>
#pragma once

#include "SupabaseClient.h"
#include <memory>

namespace quiz_examination_system
{
    class SupabaseClientManager
    {
    public:
        static SupabaseClientManager &GetInstance();

        SupabaseClient *GetClient();

        void SaveSession(hstring const &userId, hstring const &username, hstring const &role);
        void ClearSession();

        bool HasActiveSession() const;
        hstring GetUserId() const;
        hstring GetUsername() const;
        hstring GetRole() const;

        SupabaseClientManager(SupabaseClientManager const &) = delete;
        SupabaseClientManager &operator=(SupabaseClientManager const &) = delete;

    private:
        SupabaseClientManager();
        void LoadSessionFromSettings();

        std::unique_ptr<SupabaseClient> m_client;
        hstring m_userId;
        hstring m_username;
        hstring m_role;
        std::unique_ptr<SupabaseClient> m_client;
        hstring m_userId;
        hstring m_username;
        hstring m_role;
    };
}

</code>

TeacherDashboardPage.xaml.cpp:
<code>
#include "pch.h"
#include "TeacherDashboardPageNew.xaml.h"
#if __has_include("TeacherDashboardPageNew.g.cpp")
#include "TeacherDashboardPageNew.g.cpp"
#endif
#include "QuestionBankPage.xaml.h"

using namespace winrt;
using namespace Microsoft::UI::Xaml;
using namespace Microsoft::UI::Xaml::Controls;

namespace winrt::quiz_examination_system::implementation
{
    TeacherDashboardPageNew::TeacherDashboardPageNew()
    {
        InitializeComponent();

        if (TeacherNav().MenuItems().Size() > 0)
        {
            TeacherNav().SelectedItem(TeacherNav().MenuItems().GetAt(0));
            ContentFrame().Navigate(xaml_typename<quiz_examination_system::QuestionBankPage>());
        }
    }

    void TeacherDashboardPageNew::TeacherNav_SelectionChanged(
        NavigationView const &,
        NavigationViewSelectionChangedEventArgs const &e)
    {
        auto selectedItem = e.SelectedItem().try_as<NavigationViewItem>();
        if (!selectedItem)
        {
            return;
        }

        auto tag = unbox_value<hstring>(selectedItem.Tag());

        if (tag == L"QuestionBank")
        {
            ContentFrame().Navigate(xaml_typename<quiz_examination_system::QuestionBankPage>());
        }
        else if (tag == L"ManageQuizzes")
        {
        }
        else if (tag == L"ReviewAttempts")
        {
        }
    }
}

</code>

TeacherDashboardPage.xaml.h:
<code>
#pragma once

#include "TeacherDashboardPageNew.g.h"

namespace winrt::quiz_examination_system::implementation
{
    struct TeacherDashboardPageNew : TeacherDashboardPageNewT<TeacherDashboardPageNew>
    {
        TeacherDashboardPageNew();

        void TeacherNav_SelectionChanged(
            Microsoft::UI::Xaml::Controls::NavigationView const &sender,
            Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs const &e);
    };
}

namespace winrt::quiz_examination_system::factory_implementation
{
    struct TeacherDashboardPageNew : TeacherDashboardPageNewT<TeacherDashboardPageNew, implementation::TeacherDashboardPageNew>
    {
    };
}

</code>

